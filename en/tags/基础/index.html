<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>学点 | 基础</title>
    <meta name="description" content=" ">
    <link rel="canonical" href="http://gzpeng233.github.io/en/tags/%E5%9F%BA%E7%A1%80/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="基础" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://gzpeng233.github.io/en/tags/%E5%9F%BA%E7%A1%80/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="基础"/>
<meta name="twitter:description" content=""/>

    
        
    
    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
        <link rel="stylesheet" href='/css/comment.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
    
        <script src='//cdnjs.cloudflare.com/ajax/libs/valine/1.5.0/Valine.min.js'></script>
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [["\\(", "\\)"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>


    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    
    <script src="/js/yes.js"></script>
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">学点</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/en">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> Home</div>
                        </div>
                    </div>
                </a>
            
                <a href="/en/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> Posts</div>
                        </div>
                    </div>
                </a>
            
                <a href="/en/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> Categories</div>
                        </div>
                    </div>
                </a>
            
                <a href="/en/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> Tags</div>
                        </div>
                    </div>
                </a>
            
                <a href="/en/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> About</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
                
<div class="lang-box-up">
    <div class="lang-box">
        <div class="lang-now">English</div>
        <div class="wait-lang-box">
            <ul class="lang-up">
                
                <li data—permalink="http://gzpeng233.github.io/" class="lang">简体中文</li>
                
                <li data—permalink="http://gzpeng233.github.io/en/" class="lang">English</li>
                
            </ul>
        </div>
    </div>
</div>

<script type="text/javascript">
    var nowIsDefaultLang =  false ;
</script>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/en">
            <div class="burger-item">
                <i class='fa fa-home'></i> Home
            </div>
        </a>
        
        <a href="/en/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> Posts
            </div>
        </a>
        
        <a href="/en/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> Categories
            </div>
        </a>
        
        <a href="/en/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> Tags
            </div>
        </a>
        
        <a href="/en/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> About
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
    




    <div class="hero">
        
            
                <div class="hero-img">
                    <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/posts/git/git.jpg" alt="">
                </div>
            
        <div class="hero-content">
            <h1 class="hero-title">Tag: 基础</h1>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="terms-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="terms-row">
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/posts/git/git.jpg" alt='image loading failed'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="http://gzpeng233.github.io/en/posts/git/">【git】基础篇</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> postedOn: 2022-12-12 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> updatedOn: 2023-1-8 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    includedIn:
                    
                        <a href='
                                        /en/categories/git
                                    '>
                                git
                            </a>
                
            </span>
        </div>
        <div class="down-summary"><p>本篇基于 commit 介绍 git 相关的操作，看之前了解一下与 git 有关的基本概念</p></div>
    </div>
    <div class="card-readmore">
        <a href="http://gzpeng233.github.io/en/posts/git/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /en/tags/git
                        '>
                    <i class="fa fa-tag"></i> git
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /en/tags/%E5%9F%BA%E7%A1%80
                        '>
                    <i class="fa fa-tag"></i> 基础
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.jpg" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">一个青年</div>
            <div class="jianjie">
                闭门即是深山，读书随处净土
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /en/posts
                '>
            <p>posts</p>
            <p>19</p>
        </a>
        <a href='
                    /en/categories
                '>
            <p>categories</p>
            <p>5</p>
        </a>
        <a href='
                    /en/tags
                '>
            <p>tags</p>
            <p>15</p>
        </a>
    </div>

    <a href="https://github.com/gzpeng233">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/gzpeng233" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">Table of Contents</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">latest Posts</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="http://gzpeng233.github.io/en/posts/stm32_help/">
                
<a href="http://gzpeng233.github.io/en/posts/stm32_help/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/posts/stm32_help/stm32_help.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【电赛】STM32索引文档
            </div>
            <div class="other-summary"><p>STM32开发索引文档</p></div>
            <div class="other-date">2023-2-9</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://gzpeng233.github.io/en/posts/openmv_code/">
                
<a href="http://gzpeng233.github.io/en/posts/openmv_code/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/posts/openmv_code/openmv_code.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【电赛】openmv 编程指南
            </div>
            <div class="other-summary"><p>openmv开发指南</p></div>
            <div class="other-date">2023-2-9</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://gzpeng233.github.io/en/posts/nuedc_code/">
                
<a href="http://gzpeng233.github.io/en/posts/nuedc_code/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/posts/NUEDC_code/NUEDC_code.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【电赛】电赛编程指南
            </div>
            <div class="other-summary"><p>单片机 STM32 控制需要许多模块之间的配合</p></div>
            <div class="other-date">2023-2-6</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://gzpeng233.github.io/en/posts/wxminiprogram_common_problem/">
                
<a href="http://gzpeng233.github.io/en/posts/wxminiprogram_common_problem/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/posts/wxminiprogram_common_problem/wxminiprogram_common_problem.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【微信小程序】常见问题
            </div>
            <div class="other-summary"><p>微信小程序开发过程中有许多常见问题，虽难度较小，但解决方式不易找出，故列举如下</p></div>
            <div class="other-date">2023-2-4</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://gzpeng233.github.io/en/posts/can/">
                
<a href="http://gzpeng233.github.io/en/posts/can/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/posts/CAN/CAN.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【电赛】CAN通信协议
            </div>
            <div class="other-summary"><p>CAN 协议是众多协议中的一种，目前广泛应用于车联网之中，具有高速、长距离等优点</p></div>
            <div class="other-date">2023-1-30</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/gzpeng233">一个青年</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='Enter a KeyWord' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>search</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        








    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  19 ;
    var arrPosts = [{"link":"http://gzpeng233.github.io/en/posts/stm32_help/","plain":"STM32开发索引文档\n前言 什么是STM32：什么是STM32\nSTM32能做什么：STM32能做什么\nSTM32怎么选型：STM32怎么选型\nST官方 官方网址：手册 - 资源 - Search STMicrocontrollers\n中文网站：STMCU中文官网\n江科大 视频教程 STM32入门教程：STM32入门教程-2023持续更新中\n资料 STM32f103C8T6标准库开发指南：学点 | 电赛编程指南\n野火 视频教程 电机系列教学视频：【野火】电机系列教学视频，基于STM32硬件（步进电机，直流有刷电机，直流无刷电机，舵机，永磁同步电机PMSM）PID闭环、步进加减速、直线圆弧插补\nSTM32 HAL库开发：【野火】STM32 HAL库开发实战指南 教学视频 手把手教学STM32全系列\n资料 野火产品资料下载中心：野火产品资料下载中心\n野火F103 HAL库开发指南：野火F103 HAL库开发指南\n野火F4 HAL库开发指南：野火F4 HAL库开发指南\n野火F7 H7 HAL库开发指南：野火F7 H7 HAL库开发指南\n","pubDate":"2023-02-09","title":"【电赛】STM32索引文档"},{"link":"http://gzpeng233.github.io/en/posts/openmv_code/","plain":"openmv开发指南\n概括 openmv 拥有许多模块，每个模块包含不同的类，每个类拥有许多函数以实现具体功能\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 close 模块: pyb 包含类: UART: 包含函数 UART.init() UART.deinit() UART.any() UART.read() UART.readchar() UART.write() UART.writechar() ADC: ...... CAN: ...... LED: ...... sensor - 感光元件 sensor 模块用于拍摄照片。\n用法示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 close import sensor # Setup camera. 设置相机 sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.skip_frames() # Take pictures. 拍照。 while(True): sensor.snapshot() 函数 sensor.reset() 初始化相机传感器。\nsensor.set_pixformat(pixformat) 设置相机模块的像素模式。\n1 2 3 4 5 6 close pixformat 可选值: - sensor.GRAYSCALE: 8 bits/像素 - sensor.RGB565: 16 bits/像素 - sensor.BAYER: 8 bits每像素的bayer格式 - sensor.JPEG: JPEG压缩数据。仅适用于OV2640/OV5640 如果您试图使用OV2640或OV5640相机模块的较高分辨率拍摄JPEG图像， 你应该将像素格式设置为 sensor.JPEG (tip) 。 然后你可以使用控制图像质量 sensor.set_quality() (tip)\nsensor.set_framesize(framesize) 设置相机模块的帧大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 close framesize 可选值: - sensor.QQCIF: 88x72 - sensor.QCIF: 176x144 - sensor.CIF: 352x288 - sensor.QQSIF: 88x60 - sensor.QSIF: 176x120 - sensor.SIF: 352x240 - sensor.QQQQVGA: 40x30 - sensor.QQQVGA: 80x60 - sensor.QQVGA: 160x120 - sensor.QVGA: 320x240 - sensor.VGA: 640x480 - sensor.HQQQVGA: 60x40 - sensor.HQQVGA: 120x80 - sensor.HQVGA: 240x160 - sensor.B64X32: 64x32 (for use with image.find_displacement() - sensor.B64X64: 64x64 (for use with image.find_displacement() - sensor.B128X64: 128x64 (for use with image.find_displacement() - sensor.B128X128: 128x128 (for use with image.find_displacement() - sensor.MT9M114: New Rolling shutter sensor module. - sensor.LCD: 128x160 (for use with the lcd shield) - sensor.QQVGA2: 128x160 (for use with the lcd shield) - sensor.WVGA: 720x480 (for the MT9V034) - sensor.WVGA2:752x480 (for the MT9V034) - sensor.SVGA: 800x600 (only for the OV2640/OV5640 sensor) - sensor.XGA: 1024x768 (only for the OV2640/OV5640 sensor) - sensor.SXGA: 1280x1024 (only for the OV2640/OV5640 sensor) - sensor.UXGA: 1600x1200 (only for the OV2640/OV5640 sensor) - sensor.HD: 1280x720 (only for the OV2640/OV5640 sensor) - sensor.FHD: 1920x1080 (only for the OV5640 sensor) - sensor.QHD: 2560x1440 (only for the OV5640 sensor) - sensor.QXGA: 2048x1536 (only for the OV5640 sensor) - sensor.WQXGA: 2560x1600 (only for the OV5640 sensor) - sensor.WQXGA2: 2592x1944 (only for the OV5640 sensor) sensor.skip_frames([n, time]) 使用 n 个快照，让相机图像在改变相机设置后稳定下来。 n 作为普通参数传输， 例如： skip_frames(10) 跳过 10 帧。您应在改变相机设置后调用该函数。\n或者，您可通过关键字参数 time 来跳过几毫秒的帧数，例如： kip_frames(time = 2000) ，跳过2000毫秒的帧。\n若 n 和 time 皆未指定，该方法跳过300毫秒的帧。\n若二者皆指定，该方法会跳过 n 数量的帧，但将在 time 毫秒后超时。\ntip sensor.snapshot()可以应用裁剪参数来适应可用RAM中的快照，包括像素格式、帧大小、窗口和帧缓冲区。 裁剪参数将被应用以保持纵横比，并将一致保持到调用 sensor.set_framesize() 或 sensor.set_windowing() 。\nsensor.snapshot() 1 2 3 4 5 6 close /** 拍摄一张照片 * @pram None * @revert Image() 返回 Image 类 */ sensor.snapshot() 使用相机拍摄一张照片，并返回 image 对象。 OpenMV有两个图像存储区。用于正常MicroPython处理的经典堆栈/堆区可以将小图像存储在堆中。 但是，MicroPython堆只有大约100KB，这不足以存储更大的图像。因此，您的OpenMV Cam有一个辅助帧缓冲存储区， 用于存储 sensor.snapshot() 所拍摄的图像。 图像存储在该存储区域的底部。 剩下的任何内存都可供帧缓冲区堆栈使用，OpenMV Cam的固件使用它来保存用于图像处理算法的大型临时数据结构。\n如果你需要空间来容纳多个帧，你可以通过调用 sensor.alloc_extra_fb() (tip) 来“偷走”帧缓冲区空间。\n如果 sensor.set_auto_rotation() (tip) 被启用，这个方法将返回一个新的已经旋转过的 image 对象。\ntip sensor.snapshot() 可以应用裁剪参数来适应可用RAM中的快照，包括像素格式、帧大小、窗口和帧缓冲区。 裁剪参数将被应用以保持纵横比，并将一致保持到调用 sensor.set_framesize() 或 sensor.set_windowing() 。\nImage类 – 图像对象 图像对象是机器视觉操作的基本对象。\nclass image.Image(path[, copy_to_fb=False]) 或者，您可以传递一个宽度、高度和 sensor.BINARY (tip), sensor.GRAYSCALE (tip), 或 sensor.RGB565 (tip) 来创建新的空白图像对象(初始化为0 -黑色)。\n支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。\n若 copy_to_fb (tip) 为True，图像会直接载入帧缓冲区，您就可以加载大幅图片了。若为False，图像会载入MicroPython的堆中，堆远比帧缓冲区小。\n你也可以将 copy_to_fb (tip) 设置为另一个图像对象，然后该缓冲区将被复制的图像覆盖， 从而更改传递的图像对象的像素格式和分辨率。\ntip 如果 copy_to_fb 设置为True或另一个图像对象，则不继续使用传递给这个方法的旧图像对象或帧缓冲区图像对象。 由于此旧参考现在已过时，请使用此方法返回的新图像对象参考。\n图像支持“[]”记法。 令 image[index] = 8/16-bit value (tip) ，以便分配图像像素或 image[index] (tip) ，并得到一个图像像素，若是用于RGB图像的16位RGB565值的灰度图像， 这一像素则为8位。\n对于JPEG图像而言，“[]”使得您可以访问压缩的节数组形式的JPEG图像色块。由于JPEG图像是压缩的字节流形式，因而对数据组的读取和写入是不透明的。\n图像还支持读缓冲区操作。您可以把图像当作节数组对象，将图像输入所有类型的MicroPython函数。若您想传送一个图像，可以将它传递给UART /SPI/ I2C写入函数，可实现自动传送。\n函数 image.find_template(template, threshold[, roi[, step=2[, search=image.SEARCH_EX]]]) 尝试使用归一化互相关(NCC)算法在图像中找到第一个模板匹配的位置。返回匹配位置的边界框元组(x, y, w, h)，否则返回None。\ntemplate (tip) 是一个与这个图像对象相匹配的小图像对象。注意：两图像须都为灰度图。\nthreshold (tip) 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。\nroi (tip) 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi (tip) 区域内的像素。\nstep (tip) 是查找模板时需要跳过的像素数量。跳过像素可大大提高算法运行的速度。该方法只适用于SERACH_EX模式下的算法。\nsearch (tip) 可为 image.SEARCH_DS (tip) or image.SEARCH_EX (tip). image.SEARCH_DS (tip) 搜索模板所用算法较 image.SEARCH_EX (tip) 更快，但若模板位于图像边缘周围，可能无法成功搜索。image.SEARCH_EX (tip) 可对图像进行较为详尽的搜索，但其运行速度远低于 image.SEARCH_DS (tip) 。仅支持灰度图像。\nimage.draw_rectangle(x, y, w, h[, color[, thickness=1[, fill=False]]]) 在图像上绘制一个矩形。 您可以单独传递x，y，w，h或作为元组(x，y，w，h)传递。\ncolor (tip) 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。\nthickness (tip) 控制线的粗细像素。\n将 fill (tip) 设置为True以填充矩形。\n返回图像对象，以便您可以使用 . 表示法调用另一个方法。\n不支持压缩图像和bayer图像。\nUART类 – 双向串行通信总线 UART对象可通过下列方式创建和初始化:\n1 2 3 4 5 close from pyb import UART uart = UART(3, 9600, timeout_char=1000) # i使用给定波特率初始化 uart.init(9600, bits=8, parity=None, stop=1, timeout_char=1000) # 使用给定参数初始化 位数可为7、8、9。奇偶性可为None、0（偶）、1（奇）。停止位可为1或2。\n注意: 奇偶性为None时，仅支持位数为8和9。启用奇偶性时，仅支持位数为7和8。\nUART对象与流对象相似，其读取与写入均使用流对象方法:\n1 2 3 4 5 uart.read(10) # 读取10字符，返回一个字节对象 uart.read() # 读取所有可用字符 uart.readline() # 读取一条线 uart.readinto(buf) # 读取并存入缓冲区 uart.write(\u0026#39;abc\u0026#39;) # 写入3个字符 单个字符可通过下列方法读取/写入:\n1 2 uart.readchar() # 读取一个字符，并返回其整数形式 uart.writechar(42) #写入一个字符 检查是否有内容有待读取，请使用:\n1 uart.any() # 返回等待的字符数量 warning 函数 read 、 write 等适用于MicroPython v1.3.4。早期版本请使用 uart.send 和 uart.recv 。\n函数 UART.init(baudrate, bits=8, parity=None, stop=1, *, timeout=1000, flow=0, timeout_char=0, read_buf_len=64) 使用给定参数初始化UART总线:\nbaudrate (tip) 为时钟频率。 bits (tip) 为每个字符的位数，7、8或9。 parity (tip) 为奇偶校验， None (tip) ，0（偶）或1（奇）。 stop (tip) 为停止位的数量，1或2 flow (tip) 设置流控制类型。可为0、 UART.RTS (tip), UART.CTS (tip) 或 UART.RTS | UART.CTS (tip). timeout (tip) 为等待读取/写入首个字符的超时时长（以毫秒为单位）。 timeout_char (tip) 为读取或写入时字符间等待的超时时长（以毫秒为单位）。 read_buf_len (tip) 为读取缓冲区的字符长度（0为禁用）。 若波特率不能设置为期望值的5%以内，此方法将会引发故障\nwarning 奇偶校验为None时，仅支持8位和9位。启用奇偶校验时，仅支持7位和8位。\n","pubDate":"2023-02-09","title":"【电赛】openmv 编程指南"},{"link":"http://gzpeng233.github.io/en/posts/nuedc_code/","plain":"单片机 STM32 控制需要许多模块之间的配合\n相关资料 资料在 这里 放着\nstm32函数介绍 RCC 1 2 3 4 close void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState); void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState); void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState); GPIO 相关函数 1 2 3 4 5 6 7 8 close void GPIO_AFIODeInit(void);\t// 复位AFIO外设 void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);\t// 锁定 GPIO 配置 void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);\t// 配置AFIO事件输出功能 void GPIO_EventOutputCmd(FunctionalState NewState);\t// 配置AFIO事件输出功能 void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);\t// 进行引脚重映射 void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);\t// 配置AFIO的数据选择器 void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface);\t// 与以太网有关 EXTI 相关函数 1 2 3 4 5 6 7 8 9 close void EXTI_DeInit(void);\t// 清除 EXTI 配置 void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);\t// 初始化 EXTI void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);// 给EXTI结构体赋默认值 void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);\t// 软件触发EXTI外部中断 FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);\t// 获取标志位 void EXTI_ClearFlag(uint32_t EXTI_Line);\t// 清空标志位 ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);\t// 获取中断标志位 void EXTI_ClearITPendingBit(uint32_t EXTI_Line);\t// 清空中断标志位 中断函数设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 close __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD SVC_Handler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD PendSV_Handler ; PendSV Handler DCD SysTick_Handler ; SysTick Handler ; External Interrupts DCD WWDG_IRQHandler ; Window Watchdog DCD PVD_IRQHandler ; PVD through EXTI Line detect DCD TAMPER_IRQHandler ; Tamper DCD RTC_IRQHandler ; RTC DCD FLASH_IRQHandler ; Flash DCD RCC_IRQHandler ; RCC DCD EXTI0_IRQHandler ; EXTI Line 0 DCD EXTI1_IRQHandler ; EXTI Line 1 DCD EXTI2_IRQHandler ; EXTI Line 2 DCD EXTI3_IRQHandler ; EXTI Line 3 DCD EXTI4_IRQHandler ; EXTI Line 4 DCD DMA1_Channel1_IRQHandler ; DMA1 Channel 1 DCD DMA1_Channel2_IRQHandler ; DMA1 Channel 2 DCD DMA1_Channel3_IRQHandler ; DMA1 Channel 3 DCD DMA1_Channel4_IRQHandler ; DMA1 Channel 4 DCD DMA1_Channel5_IRQHandler ; DMA1 Channel 5 DCD DMA1_Channel6_IRQHandler ; DMA1 Channel 6 DCD DMA1_Channel7_IRQHandler ; DMA1 Channel 7 DCD ADC1_2_IRQHandler ; ADC1_2 DCD USB_HP_CAN1_TX_IRQHandler ; USB High Priority or CAN1 TX DCD USB_LP_CAN1_RX0_IRQHandler ; USB Low Priority or CAN1 RX0 DCD CAN1_RX1_IRQHandler ; CAN1 RX1 DCD CAN1_SCE_IRQHandler ; CAN1 SCE DCD EXTI9_5_IRQHandler ; EXTI Line 9..5 DCD TIM1_BRK_IRQHandler ; TIM1 Break DCD TIM1_UP_IRQHandler ; TIM1 Update DCD TIM1_TRG_COM_IRQHandler ; TIM1 Trigger and Commutation DCD TIM1_CC_IRQHandler ; TIM1 Capture Compare DCD TIM2_IRQHandler ; TIM2 DCD TIM3_IRQHandler ; TIM3 DCD TIM4_IRQHandler ; TIM4 DCD I2C1_EV_IRQHandler ; I2C1 Event DCD I2C1_ER_IRQHandler ; I2C1 Error DCD I2C2_EV_IRQHandler ; I2C2 Event DCD I2C2_ER_IRQHandler ; I2C2 Error DCD SPI1_IRQHandler ; SPI1 DCD SPI2_IRQHandler ; SPI2 DCD USART1_IRQHandler ; USART1 DCD USART2_IRQHandler ; USART2 DCD USART3_IRQHandler ; USART3 DCD EXTI15_10_IRQHandler ; EXTI Line 15..10 DCD RTCAlarm_IRQHandler ; RTC Alarm through EXTI Line DCD USBWakeUp_IRQHandler ; USB Wakeup from suspend __Vectors_End tip 中断向量表位于启动文件（start/startup_stm32f10x.md.s）\nNVIC 相关函数 1 2 3 4 5 6 7 close /* 注意：中断分支整个项目只能进行一次 */ void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);\t// 中断分组 void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);\t// 初始化 NVIC void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);\t// 设置中断向量表 void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);\t// 系统低功耗配置 TIM 相关函数 基本函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 close /* 初始化配置 */ void TIM_DeInit(TIM_TypeDef* TIMx);\t// 恢复缺省配置 void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);\t// 时基单元初始化 void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);\t// 时基单元结构体变量赋默认值 void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);\t// 使能计数器 void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);\t// 使能中断输出信号 void TIM_InternalClockConfig(TIM_TypeDef* TIMx);\t// 选择内部时钟 void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);\t// 选择其他定时器的时钟 void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource, uint16_t TIM_ICPolarity, uint16_t ICFilter);\t// 选择TIx捕获通道的时钟 void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);\t// 选择 ETR 通过外部时钟模式1输入的时钟 void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);\t// 选择 ETR 通过外部时钟模式2输入的时钟 void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);\t// 配置 ETR 预分频器、极性、滤波器等参数 /* 更改参数 */ void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);\t// 更改预分频值 void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);\t// 改变计数模式 void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);\t// 改变计数器的预装功能设置 void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);\t// 给计数器写入值 void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);\t// 给自动重装器写入值 uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);\t// 获取当前计数器的值 uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);\t// 获取当前预分频的值 /* 获取与清除标志位 */ FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);\t// 获取标志位 void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);\t// 清空标志位 ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);\t// 获取中断标志位 void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);\t// 清空中断标志位 输出比较函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 close void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);\t// 配置输出比较模块 void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);\t// 配置输出比较模块 void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);\t// 配置输出比较模块 void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);\t// 配置输出比较模块 void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);\t// 输出结构体赋默认值 void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);\t// 配置强制输出模式，强制输出高电平或低电平 void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);\t// 配置强制输出模式，强制输出高电平或低电平 void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);\t// 配置强制输出模式，强制输出高电平或低电平 void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);\t// 配置强制输出模式，强制输出高电平或低电平 void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);\t// 配置 CCR 预装值功能 void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);\t// 配置 CCR 预装值功能 void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);\t// 配置 CCR 预装值功能 void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);\t// 配置 CCR 预装值功能 void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);\t// 配置快速使能 void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);\t// 配置快速使能 void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);\t// 配置快速使能 void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);\t// 配置快速使能 void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);\t// 外部事件时清除 REF 信号 void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);\t// 外部事件时清除 REF 信号 void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);\t// 外部事件时清除 REF 信号 void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);\t// 外部事件时清除 REF 信号 void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);\t// 设置输出比较的极性 void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);\t// 设置输出比较的极性（互补通道 void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);\t// 设置输出比较的极性 void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);\t// 设置输出比较的极性（互补通道 void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);\t// 设置输出比较的极性 void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);\t// 设置输出比较的极性（互补通道 void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);\t// 设置输出比较的极性 void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);\t// 修改输出使能 void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);\t// 修改输出使能 void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);// 修改输出比较模式 void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);\t// 更改 CCR 寄存器的值 void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);\t// 更改 CCR 寄存器的值 void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);\t// 更改 CCR 寄存器的值 void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);\t// 更改 CCR 寄存器的值 输入捕获函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 close void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);\t// 输入捕获单元初始化 void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);\t// 初始化输入捕获单元，快速配置两个通道，配置为PWMI模式 void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);// 输入捕获结构体赋默认值 void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);\t// 选择输入触发源（从模式的触发源） void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);\t// 选择输出触发源TRGO（主模式输出） void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);\t// 选择从模式 void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);\t// 配置1通道的分频器 void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);\t// 配置2通道的分频器 void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);\t// 配置3通道的分频器 void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);\t// 配置4通道的分频器 void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD); uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);\t// 读取1通道的CCR uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);\t// 读取2通道的CCR uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);\t// 读取3通道的CCR uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);\t// 读取4通道的CCR 编码器接口函数 1 2 3 close void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode, uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);\t// 编码器接口配置 ADC相关函数 1 2 close void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);\t// 配置 ADC_CLK 分频器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 close void ADC_DeInit(ADC_TypeDef* ADCx);\t// 恢复缺省配置 void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);\t// 初始化 ADC void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);\t// ADC结构体初始化 void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);\t// 开启 ADC void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);\t// 开启 DMA 输出信号 void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);\t// 中断输出控制 void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);\t// 软件触发 ADC FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);\t// 获取软件开始转换状态（软件触发后立刻从1清零）（一般不用） void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);\t// 配置每隔几个通道间断一次 void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);\t// 启用间断模式 void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);\t// ADC规则组通道配置 void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);\t// ADC 外部触发转换控制 uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);\t// ADC 获取转换值 uint32_t ADC_GetDualModeConversionValue(void);\t// ADC 获取双模式转换值 /* 校准相关配置 */ void ADC_ResetCalibration(ADC_TypeDef* ADCx);\t// 复位校准 FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);\t// 获取复位校准状态 void ADC_StartCalibration(ADC_TypeDef* ADCx);\t// 开始校准 FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);\t// 获取开始校准状态 /* 注入组相关配置 */ void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState); void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState); void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv); void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState); void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState); FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx); void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime); void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length); void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset); uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel); /* 模拟看门狗相关配置 */ void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);\t// 是否启动模拟看门狗 void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);\t// 配置高低阈值 void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);\t// 配置看门通道 void ADC_TempSensorVrefintCmd(FunctionalState NewState);\t// ADC 温度传感器，内部电压控制 FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);\t// 获取标志位状态 void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);\t// 清空标志位 ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);\t// 获取中断状态 void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);\t// 清空中断挂起位 DMA 相关函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 close void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);\t// 恢复缺省配置 void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);\t// 初始化 DMA void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);\t// DMA 结构体初始化 void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);\t// 使能 DMA void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);\t// 中断输出使能 void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);\t// DMA 设置当前数据寄存器 uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);\t// DMA 获取当前数据寄存器 FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);\t// 获取标志位状态 void DMA_ClearFlag(uint32_t DMAy_FLAG);\t// 清空标志位 ITStatus DMA_GetITStatus(uint32_t DMAy_IT);\t// 获取中断状态 void DMA_ClearITPendingBit(uint32_t DMAy_IT);\t// 清空中断挂起位 USART 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 close void USART_DeInit(USART_TypeDef* USARTx);\t// 恢复缺省配置 void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);\t// 初始化 USART void USART_StructInit(USART_InitTypeDef* USART_InitStruct);\t// USART 结构体初始化 void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);\t// 配置同步时钟输出 void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);\t// 同步时钟输出结构体初始化 void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);\t// 开启 USART void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);\t// 开启中断 void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);\t// 开启USART到DMA的触发通道 void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);\t// 发送数据 uint16_t USART_ReceiveData(USART_TypeDef* USARTx);\t// 接收数据 FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);\t// 获取标志位状态 void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);\t// 清空标志位 ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);\t// 获取中断状态 void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);\t// 清空中断挂起位 基础模块 GPIO 具体步骤 RCC 开启时钟 GPIO_Init() 初始化 GPIO 使用输出或输入函数控制 GPIO 1 2 3 4 5 6 close GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\t//GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); EXTI 外部中断 具体步骤\nRCC 开启时钟（GPIO、AFIO） 配置 GPIO 为输入模式 配置 AFIO，选择我们使用的一路GPIO 配置 EXTI，选择边沿触发方式、触发响应方式（中断响应、事件响应） 配置 NVIC，选择优先级 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 close void CountSensor_Init(void) { /* RCC 开启时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); /* 配置 GPIO */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); /* 配置 AFIO */ GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14); /* 配置 EXTI */ EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line14; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(\u0026amp;EXTI_InitStructure); /* 配置 NVIC，中断分组 */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); /* 配置 NVIC，设置优先级 */ NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); } void EXTI15_10_IRQHandler(void) { if (EXTI_GetITStatus(EXTI_Line14) == SET) { EXTI_ClearITPendingBit(EXTI_Line14); } } tip EXTI 与 NVIC 的时钟不需手动开启\nTimer 定时中断 具体步骤\nRCC 开启时钟 选择时基单元的时钟源（定时中断选择内部时钟源） 配置时基单元 配置输出中断控制，允许更新中断到 NVIC 配置 NVIC，打开定时器中断通道，分配优先级 运行控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 close void Timer_Init(void) { /* RCC 开启时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); /* 选择时基单元的时钟源，内部时钟源 */ TIM_InternalClockConfig(TIM2); /* 配置时基单元 */ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); TIM_ClearFlag(TIM2, TIM_FLAG_Update); TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\t// 使能中断 /* 配置 NVIC，中断分组 */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); /* 配置 NVIC，配置优先级 */ NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); /* 启动计时器 */ TIM_Cmd(TIM2, ENABLE); } void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) { TIM_ClearITPendingBit(TIM2, TIM_IT_Update); } } PWM 输出 具体步骤 RCC 开启时钟 配置时基单元 配置输出比较单元 配置 GPIO 运行控制，启动计数器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header void PWM_Init(void) { /* RCC 开启时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* 配置 GPIO */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* 选择时基单元的时钟源，内部时钟源 */ TIM_InternalClockConfig(TIM2); /* 配置时基单元 */ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;\t//ARR TIM_TimeBaseInitStructure.TIM_Prescaler = 36 - 1;\t//PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); /* 配置输出比较单元 */ TIM_OCInitTypeDef TIM_OCInitStructure; TIM_OCStructInit(\u0026amp;TIM_OCInitStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = 0;\t//CCR TIM_OC3Init(TIM2, \u0026amp;TIM_OCInitStructure); /* 运行控制，启动计数器 */ TIM_Cmd(TIM2, ENABLE); } // 设置占空比 void PWM_SetCompare3(uint16_t Compare) { TIM_SetCompare3(TIM2, Compare); } // 设置预分频值 void PWM_SetPrescaler(uint16_t Prescaler) { TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate); } IC 输入捕获 具体步骤 RCC 开启时钟 GPIO 初始化为输入模式（上拉或浮空） 配置时基单元 配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器这些参数 选择从模式的触发源（TI1FP1） 选择触发后执行的操作（Reset操作） 运行控制，启动计时器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header void IC_Init(void) { /* RCC 开启时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* GPIO 初始化为输入模式（上拉或浮空） */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* 选择时基单元的时钟源，内部时钟源 */ TIM_InternalClockConfig(TIM3); /* 配置时基单元 */ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;\t//ARR TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;\t//PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); /* 配置输入捕获单元 */ TIM_ICInitTypeDef TIM_ICInitStructure; TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM_ICInitStructure.TIM_ICFilter = 0xF; TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure); /* 选择从模式的触发源，选择触发后执行的操作 */ TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1); TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset); /* 运行控制，启动计时器 */ TIM_Cmd(TIM3, ENABLE); } uint32_t IC_GetFreq(void) { return 1000000 / (TIM_GetCapture1(TIM3) + 1); } PWMI 模式 具体步骤 RCC 开启时钟 GPIO 初始化为输入模式（上拉或浮空） 配置时基单元 配置输入捕获单元 选择从模式的触发源（TI1FP1） 选择触发后执行的操作（Reset操作） 运行控制，启动计时器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header void IC_Init(void) { /* RCC 开启时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* GPIO 初始化为输入模式（上拉或浮空） */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* 选择时基单元的时钟源，内部时钟源 */ TIM_InternalClockConfig(TIM3); /* 配置时基单元 */ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;\t//ARR TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;\t//PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); /* 配置输入捕获单元 */ TIM_ICInitTypeDef TIM_ICInitStructure; TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM_ICInitStructure.TIM_ICFilter = 0xF; TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; TIM_PWMIConfig(TIM3, \u0026amp;TIM_ICInitStructure); /* 选择从模式的触发源，选择触发后执行的操作 */ TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1); TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset); /* 运行控制，启动计时器 */ TIM_Cmd(TIM3, ENABLE); } uint32_t IC_GetFreq(void) { return 1000000 / (TIM_GetCapture1(TIM3) + 1); } uint32_t IC_GetDuty(void) { return (TIM_GetCapture2(TIM3) + 1) * 100 / (TIM_GetCapture1(TIM3) + 1); } 编码器接口测速 具体步骤 RCC 开启时钟 GPIO 初始化为输入模式 配置时基单元 配置输入捕获单元，包括滤波器、极性参数 配置编码器接口模式 运行控制，启动计时器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header void Encoder_Init(void) { /* RCC 开启时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* GPIO 初始化为输入模式 */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* 配置时基单元 */ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;\t// 没用 TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;\t//ARR TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;\t//PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); /* 配置输入捕获单元，包括滤波器、极性参数 */ TIM_ICInitTypeDef TIM_ICInitStructure; TIM_ICStructInit(\u0026amp;TIM_ICInitStructure); TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM_ICInitStructure.TIM_ICFilter = 0xF; TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure); TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; TIM_ICInitStructure.TIM_ICFilter = 0xF; TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure); /* 配置编码器接口模式 */ TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising); /* 运行控制，启动计时器 */ TIM_Cmd(TIM3, ENABLE); } int16_t Encoder_Get(void) { int16_t Temp; Temp = TIM_GetCounter(TIM3); TIM_SetCounter(TIM3, 0); return Temp; } ADC 具体步骤 RCC 开启时钟（ADC和GPIO），配置 ADC_CLK 分频器 GPIO 配置为模拟输入模式 配置多路开关 配置 ADC 转换器 配置看门狗（可选） 开启中断，配置 NVIC（可选） 开启 ADC 对 ADC 进行校准（建议） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header void AD_Init(void) { /* RCC 开启时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* 配置 ADC_CLK 分频器 */ RCC_ADCCLKConfig(RCC_PCLK2_Div6); /* GPIO 配置为模拟输入模式 */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* 配置多路开关 */ ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5); /* 配置 ADC 转换器 */ ADC_InitTypeDef ADC_InitStructure; ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; ADC_InitStructure.ADC_ScanConvMode = DISABLE; ADC_InitStructure.ADC_NbrOfChannel = 1; ADC_Init(ADC1, \u0026amp;ADC_InitStructure); /* 开启 ADC */ ADC_Cmd(ADC1, ENABLE); /* 对 ADC 进行校准 */ ADC_ResetCalibration(ADC1);\t// 复位校准 while (ADC_GetResetCalibrationStatus(ADC1) == SET);\t// 等待复位校准完成 ADC_StartCalibration(ADC1);\t// 开始校准 while (ADC_GetCalibrationStatus(ADC1) == SET);\t// 等待校准完成 } uint16_t AD_GetValue(void) { ADC_SoftwareStartConvCmd(ADC1, ENABLE);\t// 软件触发转换 while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);\t// 等待转换完成 return ADC_GetConversionValue(ADC1);\t// 读取 ADC 转换结果 } DMA 具体步骤 RCC 开启时钟 初始化 DMA（包括外设和存储器的各个数据、方向、传输计数器、是否需要自动重装、选择触发源、通道优先级） 若为硬件触发，开启对应 DMA 输出（可选） 开启中断输出，配置 NVIC（可选） 开启 DMA 改变传输寄存器时需先失能，写入值后再使能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header uint16_t MyDMA_Size; void MyDMA_Init(uint32_t AddrA, uint32_t AddrB, uint16_t Size) { MyDMA_Size = Size; /* RCC 开启时钟 */ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); /* 初始化 DMA */ DMA_InitTypeDef DMA_InitStructure; DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;\t// 外设起始地址 DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\t// 外设数据宽度 DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;\t// 外设是否自增 DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;;\t// 存储器起始地址 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;;\t// 存储器数据宽度 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;;\t// 存储器是否自增 DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;\t// 传输方向 DMA_InitStructure.DMA_BufferSize = Size;\t// 缓冲区大小，即传输寄存器 DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\t// 传输模式，即是否使用自动重装 DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;\t// 选择是否存储器到存储器，即选择硬件触发或软件触发 DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;\t// 优先级 DMA_Init(DMA1_Channel1, \u0026amp;DMA_InitStructure); /* 开启 DMA */ DMA_Cmd(DMA1_Channel1, DISABLE); } void MyDMA_Transfer(void) { /* DMA失能、设置当前数据寄存器、DMA使能 */ DMA_Cmd(DMA1_Channel1, DISABLE); DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size); DMA_Cmd(DMA1_Channel1, ENABLE); /* 等待转运完成、清除转运完成标志位 */ while (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET); DMA_ClearFlag(DMA1_FLAG_TC1); } USART 串口 具体步骤 RCC 开启时钟（USART和GPIO） GPIO设置（TX配置为复用输出、RX配置为输入） 配置USART 开启中断、配置NVIC（可选） 开启USART 发送数据 初始化函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; void Serial_Init(void) { /* RCC 开启时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* GPIO设置 */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\t// 复用推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* 配置USART */ USART_InitTypeDef USART_InitStructure; USART_InitStructure.USART_BaudRate = 9600;\t// 波特率 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\t// 硬件流控制 USART_InitStructure.USART_Mode = USART_Mode_Tx;\t// 串口模式 USART_InitStructure.USART_Parity = USART_Parity_No;\t// 校验位 USART_InitStructure.USART_StopBits = USART_StopBits_1;\t// 停止位 USART_InitStructure.USART_WordLength = USART_WordLength_8b;\t// 字长 USART_Init(USART1, \u0026amp;USART_InitStructure); /* 开启USART */ USART_Cmd(USART1, ENABLE); } 相关函数封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 close /** * @brief 发送一个字节 * @param Byte: 要发送的字节数据 * @retval None */ void Serial_SendByte(uint8_t Byte) { USART_SendData(USART1, Byte); while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); } /** * @brief 发送一个数组 * @param Array: 数组的首地址，必须为 uint8_t 类型的数组 * @param Length: 数组的长度 * This parameter can be any combination of GPIO_Pin_x where x can be (0..15). * @retval None */ void Serial_SendArray(uint8_t *Array, uint16_t Length) { uint16_t i; for (i = 0; i \u0026lt; Length; i ++) { Serial_SendByte(Array[i]); } } /** * @brief 发送字符串 * @param String: 字符串的首地址 * @retval None */ void Serial_SendString(char *String) { uint8_t i; for (i = 0; String[i] != \u0026#39;\\0\u0026#39;; i ++) { Serial_SendByte(String[i]); } } /** * @brief 指数函数，即X的Y次方 * @param X：底数 * @param Y：指数 * @retval None */ uint32_t Serial_Pow(uint32_t X, uint32_t Y) { uint32_t Result = 1; while (Y --) { Result *= X;\t// 1 乘以X Y次 } return Result; } /** * @brief 发送数字 * 本质将数字手动转为字符串然后发送 * @param Number * @param Length * @retval None */ void Serial_SendNumber(uint32_t Number, uint8_t Length) { uint8_t i; for (i = 0; i \u0026lt; Length; i ++) { Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + \u0026#39;0\u0026#39;);\t// 发送Number的每一位（高位先行）\u0026#39;0\u0026#39;-\u0026gt;偏移 } } /** * @brief fputc重定向 * @param * @retval */ int fputc(int ch, FILE *f) { Serial_SendByte(ch); return ch; } /** * @brief 模拟printf重写打印字符串函数 * @retval None */ void Serial_Printf(char *format, ...) { char String[100]; va_list arg; va_start(arg, format); vsprintf(String, format, arg); va_end(arg); Serial_SendString(String); } printf 重定向方法3：\n1 2 3 4 close char String[100]; sprintf(String, \u0026#34;\\r\\nNum3=%d\u0026#34;, 333); Serial_SendString(String); 接收数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 close #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; uint8_t Serial_RxData; uint8_t Serial_RxFlag; void Serial_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\t// 上拉输入 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); USART_InitTypeDef USART_InitStructure; USART_InitStructure.USART_BaudRate = 9600; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_Init(USART1, \u0026amp;USART_InitStructure); /* 开启中断 */ USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); /* NVIC 分组 */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); /* NVIC 配置 */ NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); USART_Cmd(USART1, ENABLE); } /** * @brief 获取标志位 * @param Nonw * @retval None */ uint8_t Serial_GetRxFlag(void) { if (Serial_RxFlag == 1) { Serial_RxFlag = 0; return 1; } return 0; } /** * @brief 获取串口数据 * @param None * @retval None */ uint8_t Serial_GetRxData(void) { return Serial_RxData; } /** * @brief 串口1中断函数 * @param None * @retval None */ void USART1_IRQHandler(void) { if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) { Serial_RxData = USART_ReceiveData(USART1);\t// 获取数据 Serial_RxFlag = 1;\t// 标志位置1 USART_ClearITPendingBit(USART1, USART_IT_RXNE);\t// 清空终端挂起位 } } 收发 HEX 数据包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 close /** * @brief 发送数据包 * @param None * @retval None */ void Serial_SendPacket(void) { Serial_SendByte(0xFF); Serial_SendArray(Serial_TxPacket, 4); Serial_SendByte(0xFE); } /** * @brief 中断程序中接收数据包 * @param None * @retval None */ void USART1_IRQHandler(void) { static uint8_t RxState = 0;\t// 当前状态 static uint8_t pRxPacket = 0;\t// 接收到第几个数据 if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) { uint8_t RxData = USART_ReceiveData(USART1); if (RxState == 0)\t// 状态0：包头 { if (RxData == 0xFF) { RxState = 1;\t// 进入状态1 pRxPacket = 0;\t// 接收数据指针置零 } } else if (RxState == 1)\t// 状态1：数据 { Serial_RxPacket[pRxPacket] = RxData;\t// 接收数据 pRxPacket ++;\t// 指针后移 if (pRxPacket \u0026gt;= 4) { RxState = 2;\t// 进入状态3 } } else if (RxState == 2)\t// 状态2：包尾 { if (RxData == 0xFE) { RxState = 0;\t// 重新进入状态0 Serial_RxFlag = 1;\t// 置接收标志位为1 } } USART_ClearITPendingBit(USART1, USART_IT_RXNE); } } ","pubDate":"2023-02-06","title":"【电赛】电赛编程指南"},{"link":"http://gzpeng233.github.io/en/posts/wxminiprogram_common_problem/","plain":"微信小程序开发过程中有许多常见问题，虽难度较小，但解决方式不易找出，故列举如下\n将文件下载至手机 云存储 云存储可以将文件保存在云端，核心是 云存储ID，但下载时只能由云存储ID换为临时路径，并不能保存至手机\n官方网址：云存储| 微信开放文档 (qq.com)\n相关函数如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 close /* 上传文件 */ wx.cloud.uploadFile({ cloudPath: \u0026#39;example.png\u0026#39;, // 上传至云端的路径 filePath: \u0026#39;\u0026#39;, // 小程序临时文件路径 success: res =\u0026gt; { // 返回文件 ID console.log(res.fileID) }, fail: console.error }) /* 下载文件 */ wx.cloud.downloadFile({ fileID: \u0026#39;\u0026#39;, // 文件 ID success: res =\u0026gt; { // 返回临时文件路径 console.log(res.tempFilePath) }, fail: console.error }) /* 删除文件 */ wx.cloud.deleteFile({ fileList: [\u0026#39;a7xzcb\u0026#39;], success: res =\u0026gt; { // handle success console.log(res.fileList) }, fail: console.error }) /* 换取临时链接 */ wx.cloud.getTempFileURL({ fileList: [\u0026#39;cloud://xxx.png\u0026#39;], success: res =\u0026gt; { // fileList 是一个有如下结构的对象数组 // [{ // fileID: \u0026#39;cloud://xxx.png\u0026#39;, // 文件 ID // tempFileURL: \u0026#39;\u0026#39;, // 临时文件网络链接 // maxAge: 120 * 60 * 1000, // 有效期 // }] console.log(res.fileList) }, fail: console.error }) 保存文件 保存文件 API 具体信息：wx.openDocument(Object object)\ntip 可保存的类型有：doc、docx、xls、xlsx、ppt、pptx、pdf\n1 2 3 4 5 6 7 8 9 10 wx.openDocument({ filePath: res.tempFilePath,\t// 临时路径 showMenu: true, success: function (res) { wx.showToast({ title: \u0026#39;请在预览页面手动保存\u0026#39;, icon: \u0026#39;none\u0026#39;, }) } }) 保存视频 API 具体信息：wx.saveVideoToPhotosAlbum(Object object)\ntip 可保存的类型有：mp4\n1 2 3 4 5 6 7 8 9 wx.saveVideoToPhotosAlbum({ filePath: res.tempFilePath,\t// 临时路径 success: function (res) { wx.showToast({ title: \u0026#39;保存成功\u0026#39;, icon: \u0026#39;success\u0026#39;, }) } }) 保存图片 图片保存较为简单，手机端长按即可保存\n1 2 3 4 5 wx.previewImage({ urls: [this.data.shareDetail.content[index].url], current: this.data.shareDetail.content[index].url, showmenu: true, }) 页面滚动 page 页面 网址：wx.pageScrollTo(Object object) 示例代码：\n1 2 3 4 5 /* 滚动至页面顶端 */ wx.pageScrollTo({ scrollTop: 0, duration: 300 }) scroll-view 页面 增强 ScrollView 实例：ScrollViewContext\n滚动至指定位置：ScrollViewContext.scrollTo(Object object)\n示例代码：\n1 \u0026lt;scroll-view enhanced id=\u0026#34;shareScrollview\u0026#34;\u0026gt;\u0026lt;/scroll-view\u0026gt; 1 2 3 4 5 6 7 8 9 10 /* 滚动至顶端 */ wx.createSelectorQuery() .select(\u0026#39;#shareScrollview\u0026#39;) .node() .exec((res) =\u0026gt; { const scrollView = res[0].node; scrollView.scrollTo({ top: 0, }) }) ","pubDate":"2023-02-04","title":"【微信小程序】常见问题"},{"link":"http://gzpeng233.github.io/en/posts/can/","plain":"CAN 协议是众多协议中的一种，目前广泛应用于车联网之中，具有高速、长距离等优点\n一、CAN协议概念 1.1 CAN 协议简介 CAN 是控制器局域网络 (Controller Area Network) 的简称，它是由研发和生产汽车电子产品著称的德国 BOSCH 公司开发的，并最终成为国际标准(ISO11519以及ISO11898),是国际上应用最广泛的现场总线之一。差异点如下：\nCAN 总线协议已经成为汽车计算机控制系统和嵌入式工业控制局域网的标准总线，并且拥有以CAN 为底层协议专为大型货车和重工机械车辆设计的 J1939 协议。近年来，它具有的高可靠性和良好的错误检测能力受到重视，被广泛应用于汽车计算机控制系统和环境温度恶劣、电磁辐射强及振动大的工业环境。\n我们来贴图一个车载网络构想图\n1.2 CAN 物理层 与 I2C、SPI 等具有时钟信号的同步通讯方式不同，CAN 通讯并不是以时钟信号来进行同步的，它是一种异步通讯，只具有 CAN_High 和 CAN_Low 两条信号线，共同构成一组差分信号线，以差分信号的形式进行通讯。我们来看一个示意图\n闭环总线网络 CAN 物理层的形式主要有两种，图中的 CAN 通讯网络是一种遵循 ISO11898 标准的高速、短距离“闭环网络”，它的总线最大长度为 40m，通信速度最高为 1Mbps，总线的两端各要求有一个“120 欧”的电阻。\n开环总线网络 图中的是遵循 ISO11519-2 标准的低速、远距离“开环网络”，它的最大传输距离为 1km，最高通讯速率为 125kbps，两根总线是独立的、不形成闭环，要求每根总线上各串联有一个“2.2千欧”的电阻。\n通讯节点 从 CAN 通讯网络图可了解到，CAN 总线上可以挂载多个通讯节点，节点之间的信号经过总线传输，实现节点间通讯。由于 CAN 通讯协议不对节点进行地址编码，而是对数据内容进行编码的，所以网络中的节点个数理论上不受限制，只要总线的负载足够即可，可以通过中继器增强负载。\nCAN 通讯节点由一个 CAN 控制器及 CAN 收发器组成，控制器与收发器之间通过 CAN_Tx 及CAN_Rx 信号线相连，收发器与 CAN 总线之间使用 CAN_High 及 CAN_Low 信号线相连。其中CAN_Tx 及 CAN_Rx 使用普通的类似 TTL 逻辑信号，而 CAN_High 及 CAN_Low 是一对差分信号线，使用比较特别的差分信号，下一小节再详细说明。\n当 CAN 节点需要发送数据时，控制器把要发送的二进制编码通过 CAN_Tx 线发送到收发器，然后由收发器把这个普通的逻辑电平信号转化成差分信号，通过差分线 CAN_High 和 CAN_Low 线输出到 CAN 总线网络。而通过收发器接收总线上的数据到控制器时，则是相反的过程，收发器把总线上收到的 CAN_High 及 CAN_Low 信号转化成普通的逻辑电平信号，通过 CAN_Rx 输出到控制器中。\n例如，STM32 的 CAN 片上外设就是通讯节点中的控制器，为了构成完整的节点，还要给它外接一个收发器，在我们实验板中使用型号为 TJA1050 的芯片作为 CAN 收发器。 CAN 控制器与 CAN收发器的关系如同 TTL 串口与 MAX3232 电平转换芯片的关系， MAX3232 芯片把 TTL 电平的串口信号转换成 RS-232 电平的串口信号，CAN 收发器的作用则是把 CAN 控制器的 TTL 电平信号转换成差分信号 (或者相反) 。\n目前有以下CAN电平转换芯片（不全）\n我们来用TJA1050来看下原理图：\n差分信号 差分信号又称差模信号，与传统使用单根信号线电压表示逻辑的方式有区别，使用差分信号传输时，需要两根信号线，这两个信号线的振幅相等，相位相反，通过两根信号线的电压差值来表示\n逻辑 0 和逻辑 1。见图，它使用了 V+ 与 V-信号的差值表达出了图下方的信号。\n相对于单信号线传输的方式，使用差分信号传输具有如下优点：\n抗干扰能力强，当外界存在噪声干扰时，几乎会同时耦合到两条信号线上，而接收端只关心两个信号的差值，所以外界的共模噪声可以被完全抵消。 举一个例子，正常的单线假设逻辑1是3.3V，逻辑0假设是0V，但是如果有噪声，把3.3V弄成了0V(极端)，把0V弄成了-3.3V，此时就逻辑错误，但是有Can高/Can低一般都作用于两根线，所以两个虽然都有噪声影响，但是差值还是不变的\n能有效抑制它对外部的电磁干扰，同样的道理，由于两根信号的极性相反，他们对外辐射的电磁场可以相互抵消，耦合的越紧密，泄放到外界的电磁能量越少。 举一个例子，假设一根是10V，一根是-10V，单跟都会对外部造成电磁干扰，但是CAN可以把线拧在一起，跟编麻花一样，可以互相抵消电子干扰\n时序定位精确，由于差分信号的开关变化是位于两个信号的交点，而不像普通单端信号依靠高低两个阈值电压判断，因而受工艺，温度的影响小，能降低时序上的误差，同时也更适合于低幅度信号的电路。 由于差分信号线具有这些优点，所以在 USB 协议、485 协议、以太网协议及 CAN 协议的物理层中，都使用了差分信号传输。\nCAN 协议中的差分信号 CAN 协议中对它使用的 CAN_High 及 CAN_Low 表示的差分信号做了规定，见表及图。以高速 CAN 协议为例，当表示逻辑 1 时 (隐性电平) ，CAN_High 和 CAN_Low 线上的电压均为 2.5v，即它们的电压差 VH-V:sub:L=0V；而表示逻辑 0 时 (显性电平) ，CAN_High 的电平为 3.5V，CAN_Low 线的电平为 1.5V，即它们的电压差为 VH-V:sub:L=2V。例如，当 CAN收发器从 CAN_Tx 线接收到来自 CAN 控制器的低电平信号时 (逻辑 0)，它会使 CAN_High 输出3.5V，同时 CAN_Low 输出 1.5V，从而输出显性电平表示逻辑 0 。\n在 CAN 总线中，必须使它处于隐性电平 (逻辑 1) 或显性电平 (逻辑 0) 中的其中一个状态。假如有两个 CAN 通讯节点，在同一时间，一个输出隐性电平，另一个输出显性电平，类似 I2C 总线的“线与”特性将使它处于显性电平状态，显性电平的名字就是这样来的，即可以认为显性具有优先的意味。\n由于 CAN 总线协议的物理层只有 1 对差分线，在一个时刻只能表示一个信号，所以对通讯节点来说，CAN 通讯是半双工的，收发数据需要分时进行。在 CAN 的通讯网络中，因为共用总线，在整个网络中同一时刻只能有一个通讯节点发送信号，其余的节点在该时刻都只能接收。\n1.3 CAN 协议层 CAN 的波特率及位同步 由于 CAN 属于异步通讯，没有时钟信号线，连接在同一个总线网络中的各个节点会像串口异步通讯那样，节点间使用约定好的波特率进行通讯，特别地， CAN 还会使用“位同步”的方式来抗干扰、吸收误差，实现对总线电平信号进行正确的采样，确保通讯正常。\n位时序分解 为了实现位同步，CAN 协议把每一个数据位的时序分解成如图 所示的 SS 段、PTS 段、PBS1 段、PBS2 段，这四段的长度加起来即为一个 CAN 数据位的长度。分解后最小的时间单位是 Tq，而一个完整的位由 8~25 个 Tq 组成。为方便表示，图 中的高低电平直接代表信号逻辑 0 或逻辑 1(不是差分信号)。\n该图中表示的 CAN 通讯信号每一个数据位的长度为 19Tq，其中 SS 段占 1Tq， PTS 段占 6Tq， PBS1段占 5Tq， PBS2 段占 7Tq。信号的采样点位于 PBS1 段与 PBS2 段之间，通过控制各段的长度，可以对采样点的位置进行偏移，以便准确地采样。\n各段的作用如介绍下：\nSS 段 (SYNC SEG) SS 译为同步段，若通讯节点检测到总线上信号的跳变沿被包含在 SS 段的范围之内，则表示节点与总线的时序是同步的，当节点与总线同步时，采样点采集到的总线电平即可被确定为该位的电平。SS 段的大小固定为 1Tq。\nPTS 段 (PROP SEG) PTS 译为传播时间段，这个时间段是用于补偿网络的物理延时时间。是总线上输入比较器延时和输出驱动器延时总和的两倍。PTS 段的大小可以为 1~8Tq。\nPBS1 段 (PHASE SEG1)， PBS1 译为相位缓冲段，主要用来补偿边沿阶段的误差，它的时间长度在重新同步的时候可以加长。PBS1 段的初始大小可以为 1~8Tq。\nPBS2 段 (PHASE SEG2) PBS2 这是另一个相位缓冲段，也是用来补偿边沿阶段误差的，它的时间长度在重新同步时可以缩短。PBS2 段的初始大小可以为 2~8Tq。\n通讯的波特率 总线上的各个通讯节点只要约定好 1 个 Tq 的时间长度以及每一个数据位占据多少个 Tq，就可以确定 CAN 通讯的波特率。\n例如，假设上图中的 1Tq=1us，而每个数据位由 19 个 Tq 组成，则传输一位数据需要时间 T1bit=19us，从而每秒可以传输的数据位个数为：1x10次方/19 = 52631.6 (bps)\n这个每秒可传输的数据位的个数即为通讯中的波特率。\n同步过程分析 波特率只是约定了每个数据位的长度，数据同步还涉及到相位的细节，这个时候就需要用到数据位内的 SS、PTS、PBS1 及 PBS2 段了。根据对段的应用方式差异， CAN 的数据同步分为硬同步和重新同步。其中硬同步只是当存在“帧起始信号”时起作用，无法确保后续一连串的位时序都是同步的，而重新同步方式可解决该问题，这两种方式具体介绍如下：\n::: tabs\n@tab 硬同步\n若某个 CAN 节点通过总线发送数据时，它会发送一个表示通讯起始的信号 (即下一小节介绍的帧起始信号)，该信号是一个由高变低的下降沿。而挂载到 CAN 总线上的通讯节点在不发送数据时，会时刻检测总线上的信号。见图 ，可以看到当总线出现帧起始信号时，某节点检测到总线的帧起始信号不在节点内部时序的 SS 段范围，所以判断它自己的内部时序与总线不同步，因而这个状态的采样点采集得的数据是不正确的。所以节点以硬同步的方式调整，把自己的位时序中的 SS 段平移至总线出现下降沿的部分，获得同步，同步后采样点就可以采集得正确数据了。\n@tab 重新同步\n前面的硬同步只是当存在帧起始信号时才起作用，如果在一帧很长的数据内，节点信号与总线信号相位有偏移时，这种同步方式就无能为力了。因而需要引入重新同步方式，它利用普通数据位的高至低电平的跳变沿来同步 (帧起始信号是特殊的跳变沿)。重新同步与硬同步方式相似的地方是它们都使用 SS 段来进行检测，同步的目的都是使节点内的 SS 段把跳变沿包含起来。重新同步的方式分为超前和滞后两种情况，以总线跳变沿与 SS 段的相对位置进行区分。第一种相位超前的情况如图 ，节点从总线的边沿跳变中，检测到它内部的时序比总线的时序相对超前 2Tq，这时控制器在下一个位时序中的 PBS1 段增加 2Tq 的时间长度，使得节点与总线时序重新同步。\n第二种相位滞后的情况如图 ，节点从总线的边沿跳变中，检测到它的时序比总线的时序相对滞后 2Tq，这时控制器在前一个位时序中的 PBS2 段减少 2Tq 的时间长度，获得同步。\n在重新同步的时候，PBS1 和 PBS2 中增加或减少的这段时间长度被定义为“重新同步补偿宽度SJW* (reSynchronization Jump Width)”。一般来说 CAN 控制器会限定 SJW 的最大值，如限定了最大 SJW=3Tq 时，单次同步调整的时候不能增加或减少超过 3Tq 的时间长度，若有需要，控制器会通过多次小幅度调整来实现同步。当控制器设置的 SJW 极限值较大时，可以吸收的误差加大，但通讯的速度会下降\n:::\nCAN 的报文种类及结构 在 SPI 通讯中，片选、时钟信号、数据输入及数据输出这 4 个信号都有单独的信号线，I2C 协议包含有时钟信号及数据信号 2 条信号线，异步串口包含接收与发送 2 条信号线，这些协议包含的信号都比 CAN 协议要丰富，它们能轻易进行数据同步或区分数据传输方向。而 CAN 使用的是两条差分信号线，只能表达一个信号，简洁的物理层决定了 CAN 必然要配上一套更复杂的协议，如何用一个信号通道实现同样、甚至更强大的功能呢？CAN 协议给出的解决方案是对数据、操作命令 (如读/写) 以及同步信号进行打包，打包后的这些内容称为报文。\n1）报文的种类\n在原始数据段的前面加上传输起始标签、片选 (识别) 标签和控制标签，在数据的尾段加上 CRC校验标签、应答标签和传输结束标签，把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了，各种各样的标签就如同 SPI 中各种通道上的信号，起到了协同传输的作用。当整个数据包被传输到其它设备时，只要这些设备按格式去解读，就能还原出原始数据，这样的报文就被称为 CAN 的“数据帧”。\n为了更有效地控制通讯，CAN 一共规定了 5 种类型的帧，它们的类型及用途说明如表\n2）数据帧的结构\n数据帧是在 CAN 通讯中最主要、最复杂的报文，我们来了解它的结构，见图\n数据帧以一个显性位 (逻辑 0) 开始，以 7 个连续的隐性位 (逻辑 1) 结束，在它们之间，分别有仲裁段、控制段、数据段、CRC 段和 ACK 段。\n帧起始 SOF 段 (Start OfFrame)，译为帧起始，帧起始信号只有一个数据位，是一个显性电平，它用于通知各个节点将有数据传输，其它节点通过帧起始信号的电平跳变沿来进行硬同步。\n仲裁段 当同时有两个报文被发送时，总线会根据仲裁段的内容决定哪个数据包能被传输，这也是它名称的由来。\n仲裁段的内容主要为本数据帧的 ID 信息 (标识符)，数据帧具有标准格式和扩展格式两种，区别就在于 ID 信息的长度，标准格式的 ID 为 11 位，扩展格式的 ID 为 29 位，它在标准 ID 的基础上多出 18 位。在 CAN 协议中， ID 起着重要的作用，它决定着数据帧发送的优先级，也决定着其它节点是否会接收这个数据帧。CAN 协议不对挂载在它之上的节点分配优先级和地址，对总线的占有权是由信息的重要性决定的，即对于重要的信息，我们会给它打包上一个优先级高的 ID，使它能够及时地发送出去。也正因为它这样的优先级分配原则，使得 CAN 的扩展性大大加强，在总线上增加或减少节点并不影响其它设备。报文的优先级，是通过对 ID 的仲裁来确定的。根据前面对物理层的分析我们知道如果总线上同时出现显性电平和隐性电平，总线的状态会被置为显性电平，CAN 正是利用这个特性进行仲裁。\n若两个节点同时竞争 CAN 总线的占有权，当它们发送报文时，若首先出现隐性电平，则会失去对总线的占有权，进入接收状态。见图 ，在开始阶段，两个设备发送的电平一样，所以它们一直继续发送数据。到了图中箭头所指的时序处，节点单元 1 发送的为隐性电平，而此时节点单元 2 发送的为显性电平，由于总线的“线与”特性使它表达出显示电平，因此单元 2 竞争总线成功，这个报文得以被继续发送出去。\n仲裁段 ID 的优先级也影响着接收设备对报文的反应。因为在 CAN 总线上数据是以广播的形式发送的，所有连接在 CAN 总线的节点都会收到所有其它节点发出的有效数据，因而我们的 CAN\n控制器大多具有根据 ID 过滤报文的功能，它可以控制自己只接收某些 ID 的报文。回看数据帧格式，可看到仲裁段除了报文 ID 外，还有 RTR、IDE 和 SRR 位。\n(1) RTR 位 (Remote Transmission Request Bit)，译作远程传输请求位，它是用于区分数据帧和遥控帧的，当它为显性电平时表示数据帧，隐性电平时表示遥控帧。\n(2) IDE 位 (Identifier ExtensionBit)，译作标识符扩展位，它是用于区分标准格式与扩展格式，当它为显性电平时表示标准格式，隐性电平时表示扩展格式。\n(3) SRR 位 (Substitute Remote Request Bit)，只存在于扩展格式，它用于替代标准格式中的 RTR位。由于扩展帧中的 SRR 位为隐性位，RTR 在数据帧为显性位，所以在两个 ID 相同的标准格式报文与扩展格式报文中，标准格式的优先级较高。\n控制段 在控制段中的 r1 和 r0 为保留位，默认设置为显性位。它最主要的是 DLC 段 (Data Length Code)，译为数据长度码，它由 4 个数据位组成，用于表示本报文中的数据段含有多少个字节， DLC 段表示的数字为 0~8。\n数据段 数据段为数据帧的核心内容，它是节点要发送的原始信息，由 0~8 个字节组成，MSB 先行。\nCRC 段 为了保证报文的正确传输，CAN 的报文包含了一段 15 位的 CRC 校验码，一旦接收节点算出的CRC 码跟接收到的 CRC 码不同，则它会向发送节点反馈出错信息，利用错误帧请求它重新发送。CRC 部分的计算一般由 CAN 控制器硬件完成，出错时的处理则由软件控制最大重发数。在 CRC 校验码之后，有一个 CRC 界定符，它为隐性位，主要作用是把 CRC 校验码与后面的 ACK段间隔起来。\nACK 段 ACK 段包括一个 ACK 槽位，和 ACK 界定符位。类似 I2C 总线，在 ACK 槽位中，发送节点发送的是隐性位，而接收节点则在这一位中发送显性位以示应答。在 ACK 槽和帧结束之间由 ACK 界定符间隔开。\n帧结束 EOF 段 (End Of Frame)，译为帧结束，帧结束段由发送节点发送的 7 个隐性位表示结束。\n3）其它报文的结构\n二. STM32F407 CAN Controller介绍 STM32 的芯片中具有 bxCAN 控制器 (Basic Extended CAN)，它支持 CAN 协议 2.0A 和 2.0B 标准。该 CAN 控制器支持最高的通讯速率为 1Mb/s；可以自动地接收和发送 CAN 报文，支持使用标准ID 和扩展 ID 的报文；外设中具有 3 个发送邮箱，发送报文的优先级可以使用软件控制，还可以记录发送的时间；具有 2 个 3 级深度的接收 FIFO，可使用过滤功能只接收或不接收某些 ID 号的报文；可配置成自动重发；不支持使用 DMA 进行数据收发。框架示意图如下：\nSTM32 的有两组 CAN 控制器，其中 CAN1 是主设备，框图中的“存储访问控制器”是由 CAN1控制的，CAN2 无法直接访问存储区域，所以使用 CAN2 的时候必须使能 CAN1 外设的时钟。框图中主要包含 CAN 控制内核、发送邮箱、接收 FIFO 以及验收筛选器，下面对框图中的各个部分进行介绍。\n2.1 CAN 控制内核 框图中标号处的 CAN 控制内核包含了各种控制寄存器及状态寄存器，我们主要讲解其中的主控制寄存器 CAN_MCR 及位时序寄存器 CAN_BTR。\n主控制寄存器 CAN_MCR 主控制寄存器 CAN_MCR 负责管理 CAN 的工作模式，它使用以下寄存器位实现控制。\nDBF 调试冻结功能 DBF(Debug freeze) 调试冻结，使用它可设置 CAN 处于工作状态或禁止收发的状态，禁止收发时仍可访问接收 FIFO 中的数据。这两种状态是当 STM32 芯片处于程序调试模式时才使用的，平时使用并不影响。\nTTCM 时间触发模式 TTCM(Time triggered communication mode) 时间触发模式，它用于配置 CAN 的时间触发通信模式，在此模式下，CAN 使用它内部定时器产生时间戳，并把它保存在CAN_RDTxR、CAN_TDTxR 寄存器中。内部定时器在每个 CAN 位时间累加，在接收和发送的帧起始位被采样，并生成时间戳。利用它可以实现 ISO 11898-4 CAN 标准的分时同步通信功能。\nABOM 自动离线管理 ABOM (Automatic bus-off management) 自动离线管理，它用于设置是否使用自动离线管理功能。当节点检测到它发送错误或接收错误超过一定值时，会自动进入离线状态，在离线状态中， CAN 不能接收或发送报文。处于离线状态的时候，可以软件控制恢复或者直接使用这个自动离线管理功能，它会在适当的时候自动恢复。\nAWUM 自动唤醒 AWUM (Automatic bus-off management)，自动唤醒功能，CAN 外设可以使用软件进入低功耗的睡眠模式，如果使能了这个自动唤醒功能，当 CAN 检测到总线活动的时候，会自动唤醒。\nNART 自动重传 NART(No automatic retransmission) 报文自动重传功能，设置这个功能后，当报文发送失败时会自动重传至成功为止。若不使用这个功能，无论发送结果如何，消息只发送一次。\nRFLM 锁定模式 RFLM(Receive FIFO locked mode)FIFO 锁定模式，该功能用于锁定接收 FIFO 。锁定后，当接收 FIFO 溢出时，会丢弃下一个接收的报文。若不锁定，则下一个接收到的报文会覆盖原报文。\nTXFP 报文发送优先级的判定方法 TXFP(Transmit FIFO priority) 报文发送优先级的判定方法，当 CAN 外设的发送邮箱中有多个待发送报文时，本功能可以控制它是根据报文的 ID 优先级还是报文存进邮箱的顺序来发送。\n位时序寄存器 (CAN_BTR) 及波特率 CAN 外设中的位时序寄存器 CAN_BTR 用于配置测试模式、波特率以及各种位内的段参数。\n模式 位31 SILM：静默模式（调试）(Silent mode (debug))\n0：正常工作\n1：静默模式\n位30 LBKM：环回模式（调试）(Loop back mode (debug))\n0：禁止环回模式\n1：使能环回模式\n为方便调试，STM32 的 CAN 提供了测试模式，配置位时序寄存器 CAN_BTR 的 SILM 及 LBKM寄存器位可以控制使用正常模式、静默模式、回环模式及静默回环模式，见图。\n各个工作模式介绍如下：\n• 正常模式\n正常模式下就是一个正常的 CAN 节点，可以向总线发送数据和接收数据。\n• 静默模式\n静默模式下，它自己的输出端的逻辑 0 数据会直接传输到它自己的输入端，逻辑 1 可以被发送到总线，所以它不能向总线发送显性位 (逻辑 0)，只能发送隐性位 (逻辑 1)。输入端可以从总线接收内容。由于它只可发送的隐性位不会强制影响总线的状态，所以把它称为静默模式。这种模式一般用于监测，它可以用于分析总线上的流量，但又不会因为发送显性位而影响总线。\n• 回环模式\n回环模式下，它自己的输出端的所有内容都直接传输到自己的输入端，输出端的内容同时也会被传输到总线上，即也可使用总线监测它的发送内容。输入端只接收自己发送端的内容，不接收来自总线上的内容。使用回环模式可以进行自检。\n• 回环静默模式\n回环静默模式是以上两种模式的结合，自己的输出端的所有内容都直接传输到自己的输入端，并且不会向总线发送显性位影响总线，不能通过总线监测它的发送内容。输入端只接收自己发送端的内容，不接收来自总线上的内容。这种方式可以在“热自检”时使用，即自我检查的时候，不会干扰总线。\n以上说的各个模式，是不需要修改硬件接线的，例如，当输出直接连输入时，它是在 STM32 芯片内部连接的，传输路径不经过 STM32 的 CAN_Tx/Rx 引脚，更不经过外部连接的 CAN 收发器，只有输出数据到总线或从总线接收的情况下才会经过 CAN_Tx/Rx 引脚和收发器\n位时序及波特率 STM32 外设定义的位时序与我们前面解释的 CAN 标准时序有一点区别，见图\nSTM32 的 CAN 外设位时序中只包含 3 段，分别是同步段 SYNC_SEG、位段 BS1 及位段 BS2，采样点位于 BS1 及 BS2 段的交界处。其中 SYNC_SEG 段固定长度为 1Tq，而 BS1 及 BS2 段可以\n在位时序寄存器 CAN_BTR 设置它们的时间长度，它们可以在重新同步期间增长或缩短，该长度SJW 也可在位时序寄存器中配置。\n理解 STM32 的 CAN 外设的位时序时，可以把它的 BS1 段理解为是由前面介绍的 CAN 标准协议中 PTS 段与 PBS1 段合在一起的，而 BS2 段就相当于 PBS2 段。\n了解位时序后，我们就可以配置波特率了。通过配置位时序寄存器 CAN_BTR 的 TS1[3:0] 及\nTS2[2:0] 寄存器位设定 BS1 及 BS2 段的长度后，我们就可以确定每个 CAN 数据位的时间：\nBS1 段时间：TS1=Tq x (TS1[3:0] + 1)，\nBS2 段时间：TS2= Tq x (TS2[2:0] + 1)，\n一个数据位的时间：T1bit =1Tq+TS1+TS2=1+ (TS1[3:0] + 1)+ (TS2[2:0] + 1)= N Tq\n其中单个时间片的长度 Tq 与 CAN 外设的所挂载的时钟总线及分频器配置有关，CAN1 和 CAN2外设都是挂载在 APB1 总线上的，而位时序寄存器 CAN_BTR 中的 BRP[9:0] 寄存器位可以设置\nCAN波特率=Fpclk1/((CAN_BS1+CAN_BS2+1)*CAN_Prescaler)\n其中clk为42M！\n推荐一个CAN波特率计算器\n2.2 CAN 发送邮箱 回到图 中的 CAN 外设框图，在标号处的是 CAN 外设的发送邮箱，它一共有 3 个发送邮箱，即最多可以缓存 3 个待发送的报文。每个发送邮箱中包含有标识符寄存器 CAN_TIxR、数据长度控制寄存器 CAN_TDTxR 及 2 个数据寄存器 CAN_TDLxR、CAN_TDHxR，它们的功能见表\n当我们要使用 CAN 外设发送报文时，把报文的各个段分解，按位置写入到这些寄存器中，并对标识符寄存器 CAN_TIxR 中的发送请求寄存器位 TMIDxR_TXRQ 置 1，即可把数据发送出去。其中标识符寄存器 CAN_TIxR 中的 STDID 寄存器位比较特别。我们知道 CAN 的标准标识符的总位数为 11 位，而扩展标识符的总位数为 29 位的。当报文使用扩展标识符的时候，标识符寄存器 CAN_TIxR 中的 STDID[10:0] 等效于 EXTID[18:28] 位，它与 EXTID[17:0] 共同组成完整的 29位扩展标识符。\n2.3 CAN 接收 FIFO 图 中的 CAN 外设框图，在标号处的是 CAN 外设的接收 FIFO，它一共有 2 个接收 FIFO，每个 FIFO 中有 3 个邮箱，即最多可以缓存 6 个接收到的报文。当接收到报文时，FIFO 的报文计数器会自增，而 STM32 内部读取 FIFO 数据之后，报文计数器会自减，我们通过状态寄存器可获知报文计数器的值，而通过前面主控制寄存器的 RFLM 位，可设置锁定模式，锁定模式下 FIFO溢出时会丢弃新报文，非锁定模式下 FIFO 溢出时新报文会覆盖旧报文。跟发送邮箱类似，每个接收 FIFO 中包含有标识符寄存器 CAN_RIxR、数据长度控制寄存器CAN_RDTxR 及 2 个数据寄存器 CAN_RDLxR、CAN_RDHxR，它们的功能见表。\n通过中断或状态寄存器知道接收 FIFO 有数据后，我们再读取这些寄存器的值即可把接收到的报文加载到 STM32 的内存中\n2.4 验收筛选器 图 中的 CAN 外设框图，在标号处的是 CAN 外设的验收筛选器，一共有 28 个筛选器组，每个筛选器组有 2 个寄存器，CAN1 和 CAN2 共用的筛选器的。在 CAN 协议中，消息的标识符与节点地址无关，但与消息内容有关。因此，发送节点将报文广播给所有接收器时，接收节点会根据报文标识符的值来确定软件是否需要该消息，为了简化软件的工作，STM32 的 CAN 外设接收报文前会先使用验收筛选器检查，只接收需要的报文到 FIFO中。\n筛选器工作的时候，可以调整筛选 ID 的长度及过滤模式。根据筛选 ID 长度来分类有有以下两种：\n(1) 检查 STDID[10:0]、EXTID[17:0]、IDE 和 RTR 位，一共 31 位。\n(2) 检查 STDID[10:0]、RTR、IDE 和 EXTID[17:15]，一共 16 位。\n通过配置筛选尺度寄存器 CAN_FS1R 的 FSCx 位可以设置筛选器工作在哪个尺度。而根据过滤的方法分为以下两种模式：\n(1) 标识符列表模式，它把要接收报文的 ID 列成一个表，要求报文 ID 与列表中的某一个标识符完全相同才可以接收，可以理解为白名单管理。\n(2) 掩码模式，它把可接收报文 ID 的某几位作为列表，这几位被称为掩码，可以把它理解成关键字搜索，只要掩码 (关键字) 相同，就符合要求，报文就会被保存到接收 FIFO。通过配置筛选模式寄存器 CAN_FM1R 的 FBMx 位可以设置筛选器工作在哪个模式。不同的尺度和不同的过滤方法可使筛选器工作在图 的 4 种状态。\n每组筛选器包含 2 个 32 位的寄存器，分别为 CAN_FxR1 和 CAN_FxR2，它们用来存储要筛选的ID 或掩码，各个寄存器位代表的意义与图中两个寄存器下面“映射”的一栏一致，各个模式的说明见表。\n例如下面的表格所示，在掩码模式时，第一个寄存器存储要筛选的 ID，第二个寄存器存储掩码，掩码为 1 的部分表示该位必须与 ID 中的内容一致，筛选的结果为表中第三行的 ID 值，它是一组包含多个的 ID 值，其中 x 表示该位可以为 1 可以为 0。\n而工作在标识符模式时，2 个寄存器存储的都是要筛选的 ID，它只包含 2 个要筛选的 ID 值 (32位模式时)。\n如果使能了筛选器，且报文的 ID 与所有筛选器的配置都不匹配，CAN 外设会丢弃该报文，不存入接收 FIFO。\n2.5 整体控制逻辑 回到图 结构框图，图中的标号处表示的是 CAN2 外设的结构，它与 CAN1 外设是一样的，他们共用筛选器且由于存储访问控制器由 CAN1 控制，所以要使用 CAN2 的时候必须要使能CAN1 的时钟。其中 STM32F103 系列芯片不具有 CAN2 控制器。\n摘自 靠这篇我竟然2天理解了CAN协议！\n","pubDate":"2023-01-30","title":"【电赛】CAN通信协议"},{"link":"http://gzpeng233.github.io/en/posts/pid/","plain":"PID 算法是单片机项目中常见的算法，常用于无人机、小车、平衡车等项目中\nPID基本知识储备 控制系统概述 开环控制系统\n一般开环控制系统 前馈控制系统 闭环控制系统\n单闭环 双闭环 复合控制系统\n前馈—反馈复合控制系统： 参数详解\n误差 控制器输出 执行器输出 系统输出 连续与离散信号 图形表示\n信号算数表示 $$ \\int_0^t x(t)dt \\rightarrow \\sum_{n=0}^N X(n) $$\n$$ \\frac{dx(t)}{dt} \\rightarrow \\frac{x(n)-x(n-1)}{\\Delta t} $$\nPID 公式讲解 PID 公式讲解（抽象） 理论公式： $$ C = \\frac{1}{p}(e+\\frac{1}{T_i}\\int_0^t e dt+T_d\\frac{de}{dt}) $$ 实际常用公式：\n连续信号 $$ C = K_pe+K_i\\int_0^t e dt+K_d\\frac{de}{dt} $$\n离散信号 $$ C = K_{p}e_{i}+K_i\\sum_{i=0}^N e_i + \\frac{K_d(e_i-e_{i-1})}{\\Delta t} $$\n$$ = K_{p}e_{i}+K_i\\sum_{i=0}^N e_i + K_d(e_i-e_{i-1}) $$\nPID 公式讲解（形象，具体实例） 汽车\nprimary PID 算法可以单独使用其中之一参数，例如 P，也可使用其中之二的结合，例如 P 与 I，或者使用全部参数 P、I、D\n对于汽车而言，可以构建一个简单的单闭环控制系统，误差 e 为 期望位置与实际位置的差，这里单独使用一个参数 P，如下所示\n期望位置 P值 实际位置 误差 速度 100 0.1 0 100 10 m/s 100 0.1 10 90 9 m/s 100 0.1 19 81 8.1 m/s tip 可以画出具体的条形图来帮助理解\n通过以上例子可以发现，给出适合的 P 值即可使得小车到达期望位置，不同的 P 值，耗费时间不同，功耗不同……\n飞行器\n首先构建一个单闭环控制系统 由于重力影响，单独悬停需要一定的转速，故对于飞行器而言，至少需要两个参数 P 与 I\n假设飞行器到达了期望位置，那么使用一个参数P的情况下，最终PID控制器的输出为0，飞行器发动机停止转动，不能达到预期效果；使用 P 与 I 的情况下，I 的引入会使得PID控制器输出拥有累加效果，最终比例输出为0，但由于I的输出不为0，飞行器可悬停在期望位置\nprimary 但由于 I 的引入，可能出现波动的情况，倘若波动较大不能满足需求，可引入第三个参数 D，来消除影响\n但D的引入又会增大位置移动的时间，故 P I D 三个参数需要互相配合调整\nPID 参数整定\n首先由小到大调节 P 值，使得能够适当符合预期效果 如果第一步不能实现预期效果（例如飞行器），由小到大增大 I 值，观察波动情况 如果波动情况符合预期，则无需继续调节，调节结束 如果波动情况不符合预期，由小到大调节 D 值，观察耗费时间，在合适的地方停止，结束调节 其余相关控制知识\n积分限幅\n无人机场景：当固定无人机于起始位置时，由于误差的积累，I 项会无限增大，进而导致之后波动剧烈，故对积分项进行限幅，设置最大值。\n例如： 当 I \u0026gt; 20 时，I =20\n积分分离\n无人机场景：当无人机已到达期望位置100m，此时改变期望值为1000m，由于误差较大，短暂的积累作用也会造成剧烈的波动，故进行积分分离\n例如：若误差大于400m，则 I 项失去效果，否则不做改变\n微分先行\n原本的控制图：\n改变后的控制图：\ntip 这样做的好处在于可以降低期望高度突变带给 D 的影响\n实践使用 前期分析 graph LR;\rstm32[stm32]--PID输出值--\u0026gt;motor[motor]\rmotor--\u0026#34;电机输出（角度、速度等）\u0026#34;--\u0026gt;stm32 tip 发送与接收遵循 CAN 协议\nRM电机M3508速度单环 控制系统\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 close chassis_motor_pid[i].speedPID.target = 500;\t// （rps/s）要考虑减速比 chassis_motor_pid[i].speedPID.current = chassis_motor_pid[i].speed_rpm; pid_calc(\u0026amp;chassis_motor_pid[i].speedPID); // 位置pid算法（基础版） void pid_calc(_pid* pid) { pid-\u0026gt;e = pid-\u0026gt;target - pid-\u0026gt;current; pid-\u0026gt;p_out = (int32_t)(pid-\u0026gt;Kp * pid-\u0026gt;e); pid-\u0026gt;i_out += (int32_t)(pid-\u0026gt;Ki * pid-\u0026gt;e); pid-\u0026gt;d_out = (int32_t)(pid-\u0026gt;Kd * (pid-\u0026gt;e - pid-\u0026gt;last_e)); pid-\u0026gt;total_out = pid-\u0026gt;p_out + pid-\u0026gt;i_out + pid-\u0026gt;d_out; // pid输出限幅 limit(\u0026amp;(pid-\u0026gt;total_out), pid-\u0026gt;MaxOutput); pid-\u0026gt;last_e = pid-\u0026gt;e; } // 位置pid算法（积分限幅） void pid_calc(_pid* pid) { pid-\u0026gt;e = pid-\u0026gt;target - pid-\u0026gt;current; pid-\u0026gt;p_out = (int32_t)(pid-\u0026gt;Kp * pid-\u0026gt;e); pid-\u0026gt;i_out += (int32_t)(pid-\u0026gt;Ki * pid-\u0026gt;e); // 积分限幅 limit(\u0026amp;(pid-\u0026gt;i_out), pid-\u0026gt;IntegralLimit); pid-\u0026gt;d_out = (int32_t)(pid-\u0026gt;Kd * (pid-\u0026gt;e - pid-\u0026gt;last_e)); pid-\u0026gt;total_out = pid-\u0026gt;p_out + pid-\u0026gt;i_out + pid-\u0026gt;d_out; // pid输出限幅 limit(\u0026amp;(pid-\u0026gt;total_out), pid-\u0026gt;MaxOutput); pid-\u0026gt;last_e = pid-\u0026gt;e; } // 位置pid算法（积分分离） void pid_calc(_pid* pid) { pid-\u0026gt;e = pid-\u0026gt;target - pid-\u0026gt;current; pid-\u0026gt;p_out = (int32_t)(pid-\u0026gt;Kp * pid-\u0026gt;e); // 积分分离 if(fabs(pid-\u0026gt;e) \u0026lt; I_Band) { pid-\u0026gt;i_out += (int32_t)(pid-\u0026gt;Ki * pid-\u0026gt;e); } else { pid-\u0026gt;i_out = 0; } pid-\u0026gt;d_out = (int32_t)(pid-\u0026gt;Kd * (pid-\u0026gt;e - pid-\u0026gt;last_e)); pid-\u0026gt;total_out = pid-\u0026gt;p_out + pid-\u0026gt;i_out + pid-\u0026gt;d_out; // pid输出限幅 limit(\u0026amp;(pid-\u0026gt;total_out), pid-\u0026gt;MaxOutput); pid-\u0026gt;last_e = pid-\u0026gt;e; } // 位置pid算法（积分限幅和积分分离） void pid_calc(_pid* pid) { pid-\u0026gt;e = pid-\u0026gt;target - pid-\u0026gt;current; pid-\u0026gt;p_out = (int32_t)(pid-\u0026gt;Kp * pid-\u0026gt;e); // 积分分离 if(fabs(pid-\u0026gt;e) \u0026lt; I_Band) { pid-\u0026gt;i_out += (int32_t)(pid-\u0026gt;Ki * pid-\u0026gt;e); limit(\u0026amp;(pid-\u0026gt;i_out), pid-\u0026gt;IntegralLimit);\t// 积分限幅 } else { pid-\u0026gt;i_out = 0; } pid-\u0026gt;d_out = (int32_t)(pid-\u0026gt;Kd * (pid-\u0026gt;e - pid-\u0026gt;last_e)); pid-\u0026gt;total_out = pid-\u0026gt;p_out + pid-\u0026gt;i_out + pid-\u0026gt;d_out; // pid输出限幅 limit(\u0026amp;(pid-\u0026gt;total_out), pid-\u0026gt;MaxOutput); pid-\u0026gt;last_e = pid-\u0026gt;e; } RM电机6020角度双环 控制系统\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 close manipulator_motor_pid[i].AnglePID.target = 30; update_angle(\u0026amp;manipulator_motor_pid[i]._angle, manipulator_motor_pid[i].angle) manipulator_motor_pid[i].AnglePID.current = manipulator_motor_pid[i]._angle.angle; pid_calc(\u0026amp;manipulator_motor_pid[i].AnglePID); manipulator_motor_pid[i].SpeedPID.target = manipulator_motor_pid[i].AnglePID.total_out; manipulator_motor_pid[i].SpeedPID.current = manipulator_motor_pid[i].speed_rpm; pid_calc(\u0026amp;manipulator_motor_pid[i].SpeedPID); // 具体pid算法同上 pid_calc(); // 6020角度更新 void update_angle(motor_angle* _angle, uint16_t angle_fb) { _angle-\u0026gt;encoder = angle_fb; if( angle-\u0026gt;encoder is init) { if(_angle-\u0026gt;encoder - _angle-\u0026gt;last_encoder \u0026gt; 4096) _angle-\u0026gt;round_cnt --; else if(_angle-\u0026gt;encoder - _angle-\u0026gt;last_encoder \u0026lt; -4096) _angle-\u0026gt;round_cnt ++; } else { _angle-\u0026gt;encoder_offset = _angle-\u0026gt;encoder; _angle-\u0026gt;encoder_is_init = 1; } _angle-\u0026gt;angle_offset = _angle-\u0026gt;encoder_offset / 8192.0f * 360.0f; _angle-\u0026gt;total_encoder = _angle-\u0026gt;round_cnt * 8192 + _angle-\u0026gt;encoder - _angle-\u0026gt;encoder_offset; _angle-\u0026gt;angle = _angle-\u0026gt;total_encoder / 8192.0f * 360.0f; } 上述笔记基于 从不懂到会用！PID从理论到实践~ 所记\n","pubDate":"2023-01-28","title":"【电赛】PID算法"},{"link":"http://gzpeng233.github.io/en/posts/git_common_codes/","plain":"git 中代码非常多，总结下常见的代码便于使用\n基础 1 2 3 4 5 6 git init\t// 初始化git仓库 git add .\t// 将工作区的更改添加至暂存区（不包括删除的文件） git add --update\t// 将工作区的更改添加至暂存区（只包括已被tracked的文件） git add -u\t// （上面代码的缩写） git add -A\t// 将工作区的更改添加至暂存区（包括所有的更改） git commit -m \u0026#34;this is commit message.\u0026#34;\t// 提交暂存区的更改，并填写提交信息 tip 提交信息填写规范能够提高开发效率，常见规范见 Git Commit message 编写指南 分支 1 2 3 4 5 6 7 git branch\t// 查看所有分支 git branch \u0026lt;分支\u0026gt;\t// 创建\u0026lt;分支\u0026gt; git switch \u0026lt;分支\u0026gt;\t// 切换至\u0026lt;分支\u0026gt; git checkout \u0026lt;分支\u0026gt;\t// 切换至\u0026lt;分支\u0026gt; git switch -c \u0026lt;分支\u0026gt;\t// 创建并切换至\u0026lt;分支\u0026gt; git checkout -b \u0026lt;分支\u0026gt;\t// 创建并切换至\u0026lt;分支\u0026gt; git branch --delete \u0026lt;分支名\u0026gt;\t// 删除\u0026lt;分支\u0026gt; 远程 远程仓库构建与删除 1 2 3 4 5 git remote\t// 查看当前远程仓库 git remote -v\t// 查看当前远程仓库具体信息 git remote add \u0026lt;别名\u0026gt; \u0026lt;远程仓库链接\u0026gt;\t// 添加远程仓库 git remote rm \u0026lt;别名\u0026gt;\t// 删除远程仓库 git remote set-url \u0026lt;别名\u0026gt; \u0026lt;远程仓库链接\u0026gt;\t// 修改远远程仓库链接 远程仓库代码上传与下载 1 2 3 4 5 6 7 8 9 git push \u0026lt;别名\u0026gt; \u0026lt;分支\u0026gt;\t// 将\u0026lt;分支\u0026gt;上代码上传至\u0026lt;别名\u0026gt;中对应分支上 git push -u \u0026lt;别名\u0026gt; \u0026lt;分支\u0026gt;\t// 将\u0026lt;分支\u0026gt;上代码上传至\u0026lt;别名\u0026gt;中对应分支上，并设为 push 默认项 git push \u0026lt;别名\u0026gt; \u0026lt;本地分支\u0026gt;:\u0026lt;远程仓库分支\u0026gt;\t// 将\u0026lt;本地分支\u0026gt;上代码上传\u0026lt;远程仓库分支\u0026gt;上 git push \u0026lt;别名\u0026gt; :\u0026lt;远程仓库分支\u0026gt;\t// 删除\u0026lt;别名\u0026gt;\u0026lt;远程仓库分支\u0026gt; git push \u0026lt;别名\u0026gt; --delete master\t// 删除\u0026lt;别名\u0026gt;\u0026lt;远程仓库分支\u0026gt; git push \u0026lt;别名\u0026gt;\t// 将当前分支（已与远程关联）推送到\u0026lt;别名\u0026gt;上对应的分支 git fetch \u0026lt;别名\u0026gt; \u0026lt;分支\u0026gt;\t// 抓取\u0026lt;别名\u0026gt;上的\u0026lt;分支\u0026gt;代码到本地仓库 git fetch \u0026lt;别名\u0026gt; \u0026lt;远程仓库分支\u0026gt;:\u0026lt;本地分支\u0026gt;\t// 抓取\u0026lt;别名\u0026gt;上的\u0026lt;远程仓库分支\u0026gt;代码到本地仓库并链接到\u0026lt;本地分支\u0026gt;上 ","pubDate":"2023-01-24","title":"【git】常用代码总结"},{"link":"http://gzpeng233.github.io/en/posts/commit_message_guidelines/","plain":"好的git提交信息能够大大提高开发效率，以及节省新版本发布特性文档的编写时间\n介绍 在 Git 中，每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。这个操作将通过 git commit 完成。\n1 git commit -m \u0026#34;hello world\u0026#34; primary 上面代码的-m参数，就是用来指定 commit mesage 的。\n如果一行不够，可以只执行git commit，就会跳出文本编译器，让你写多行。\n1 git commit 格式 Commit message 包括三个部分：Header，Body 和 Footer。可以用下方的格式表示它的结构。\n1 2 3 4 5 \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; // 空一行 \u0026lt;body\u0026gt; // 空一行 \u0026lt;footer\u0026gt; primary 其中，Header 是必需的，Body 和 Footer 可以省略(默认忽略)，一般我们在 git commit 提交时指定的 -m 参数，就相当于默认指定 Header。\nprimary 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\nHeader Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。\ntype feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果 type 为 feat 和 fix ，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。\nscope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视仓库不同而不同。\nsubject subject是 commit 目的的简短描述，不超过50个字符。\n以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\n1 2 3 4 5 6 7 More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点。\n使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。 Footer Footer 部分只用于两种情况。\n不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: \u0026#39;attribute\u0026#39;, } After: scope: { myAttr: \u0026#39;@\u0026#39;, } The removed `inject` wasn\u0026#39;t generaly useful for directives so there should be no code using it. 关闭 Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\n1 Closes #234 也可以一次关闭多个 issue 。\n1 Closes #123, #245, #992 Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\n1 2 revert: feat(pencil): add \u0026#39;graphiteWidth\u0026#39; option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit \u0026lt;hash\u0026gt;，其中的 hash 是被撤销 commit 的 SHA 标识符。\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。\n摘自 阮一峰 博客 《Git Commit message 编写指南》\n","pubDate":"2023-01-24","title":"【git】Commit message 编写指南"},{"link":"http://gzpeng233.github.io/en/posts/search_history_page/","plain":"对于搜索历史页面的编写，关键在于本地缓存的使用\n本地缓存 相关操作参考如下：\n保存数据至本地缓存：wx.setStorageSync(string key, any data)\n从本地缓存移除数据：wx.removeStorageSync(string key)\n从本地缓存读取数据：wx.getStorageSync(string key)\ntip 以 Sync 结尾表示该函数是同步函数，只有运行完该函数，才会继续往下执行\n主要代码 首次加载获取数据 1 2 3 4 5 6 7 8 9 onLoad() { this.getStorageHistoryList() // 获取本地缓存的历史记录 }, if (wx.getStorageSync(\u0026#39;search_history\u0026#39;)) { this.setData({ list: wx.getStorageSync(\u0026#39;search_history\u0026#39;).slice(0, 15) }) } 搜索设计 以下是搜索模块，方便多次调用故封装函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 search(keywords) { // 判断搜索历史中是否包含当前关键词 if (this.data.list.some(i =\u0026gt; i == keywords)) { var idx = this.data.list.findIndex(i =\u0026gt; i == keywords) this.data.list.splice(idx, 1) } this.data.list.unshift(keywords) // 更新页面 this.setData({ list: this.data.list }) // 将当前搜索历史存储至本地缓存 wx.setStorage({ key: \u0026#39;search_history\u0026#39;, data: this.data.list, }) // 跳转至搜索页面 wx.navigateTo({ url: `../searchShare/searchShare?keywords=${keywords}`, }) } 搜索方法具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 搜索内容 searchContent(e) { var keywords = this.data.searchkeywords if (!keywords) { wx.showToast({ title: \u0026#39;请输入关键词\u0026#39;, icon: \u0026#39;error\u0026#39;, }) return } this.search(keywords) }, // 搜索热门内容 searchHotContent(e) { var index = e.currentTarget.dataset.index var keywords = this.data.hot_list[index] // 从热门搜索中获取关键词 this.search(keywords) }, // 搜索历史记录 searchHistoryContent(e) { var index = e.currentTarget.dataset.index var keywords = this.data.list[index] // 从热门搜索中获取关键词 this.search(eywords) } 清空搜索历史 1 2 3 4 5 6 clearHistory() { this.setData({ list: [] }) wx.removeStorageSync(\u0026#39;search_history\u0026#39;) } UI设计 页面设计：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!-- 搜索框 --\u0026gt; \u0026lt;van-search value=\u0026#34;{{ searchkeywords }}\u0026#34; clearable placeholder=\u0026#34;请输入搜索关键词\u0026#34; bind:search=\u0026#34;searchContent\u0026#34; bind:change=\u0026#34;changeKeywords\u0026#34; /\u0026gt; \u0026lt;!-- 热门搜索 --\u0026gt; \u0026lt;view wx:if=\u0026#34;{{ hot_list.length }}\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;title\u0026#34;\u0026gt;热门搜索\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-row list\u0026#34;\u0026gt; \u0026lt;block wx:for=\u0026#34;{{hot_list}}\u0026#34; wx:key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;c_item color\u0026#34; data-index=\u0026#34;{{index}}\u0026#34; catchtap=\u0026#34;searchHotContent\u0026#34;\u0026gt;{{item}}\u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 搜索历史 --\u0026gt; \u0026lt;view wx:if=\u0026#34;{{ list.length }}\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-row j_b\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;title\u0026#34;\u0026gt;搜索历史\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-row list\u0026#34;\u0026gt; \u0026lt;block wx:for=\u0026#34;{{list}}\u0026#34; wx:key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;c_item\u0026#34; data-index=\u0026#34;{{index}}\u0026#34; catchtap=\u0026#34;searchHistoryContent\u0026#34;\u0026gt;{{item}}\u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 清空搜索历史 --\u0026gt; \u0026lt;view wx:if=\u0026#34;{{ list.length }}\u0026#34; class=\u0026#34;flex-row center distante_from_upper\u0026#34; bindtap=\u0026#34;clearHistory\u0026#34;\u0026gt; \u0026lt;van-icon name=\u0026#34;delete-o\u0026#34; /\u0026gt; \u0026lt;view class=\u0026#34;clear\u0026#34;\u0026gt;清空搜索历史\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; CSS设计：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* pages/searchingShare/searchingShare.wxss */ .title { font-size: 30rpx; font-weight: 600; color: #333333; margin-left: 15px; margin-top: 15px; } .flex-row { display: flex; flex-direction: row; } .c_item { font-size: 25rpx; height: 49rpx; line-height: 49rpx; padding: 0 13px; background: rgba(131, 183, 253, 0.1); border-radius: 31rpx; justify-content: center; margin-bottom: 24rpx; margin-right: 24rpx; white-space: pre; color: #999; } .list { margin-top: 10px; margin-left: 10px; flex-wrap: wrap; } .color { color: #83B7FD; } .clear { color: #999; font-size: 12px; } .center{ display: flex; justify-content: center; } .distante_from_upper{ margin-top: 7px; } 最终效果 ","pubDate":"2023-01-20","title":"【微信小程序】搜索历史页面"},{"link":"http://gzpeng233.github.io/en/posts/communication_protocol/","plain":"通信 通信的目的： 将一个设备的数据传送到另一个设备， 扩展硬件系统\n通信协议： 制定通信的规则， 通信双方按照协议规则进行数据收发\n有关通信协议\n::: tabs\n@tab 双工\n全双工是指双方可以同时像对方发送数据，同时接收对方发送来的数据 半双工是指双方之间可以互相通信，但不能同时通信，即设备 A 像 B 发送数据，此时设备 B 只能接收数据，不能再向设备 A 发送数据 单工是指只能由一个设备向另一个设备发送数据 @tab 时钟\n同步是指双方的时钟必须同步，即同时产生上升沿，同时产生下降沿 异步对双方的时钟要求不大，但双方的读写频率需相同 @tab 电平\n单端是指常见的 3.3V 与 GND 或 5V 与 GND 差分是指通过两个电压之间的差值来传送数据 @tab 设备\n点对点即是两两通信 多设备则可多台设备互相通信 :::\n串口通信 串口是一种应用十分广泛的通讯接口， 串口成本低、 容易使用、 通信线路简单， 可实现两个设备的互相通信\n单片机的串口可以使单片机与单片机、 单片机与电脑、 单片机与各式各样的模块互相通信， 极大地扩展了单片机的应用范围， 增强了单片机系统的硬件实力\n硬件电路 简单双向串口通信有两根通信线（发送端TX和接收端RX）\nTX与RX要交叉连接\n当只需单向的数据传输时， 可以只接一根通信线\n当电平标准不一致时， 需要加电平转换芯片\n电平标准 电平标准是数据1和数据0的表达方式， 是传输线缆中人为规定的电压与数据的对应关系， 串口常用的电平标准有如下三种：\nTTL电平： +3.3V 或 +5V 表示 1， 0V 表示0\nRS232电平： -3~-15V 表示 1， +3~+15V 表示 0\nRS485电平： 两线压差 +2~+6V 表示 1， -2~-6V 表示 0（差分信号）\n串口参数及时序 波特率： 串口通信的速率，单位为 码元 /秒\n起始位： 标志一个数据帧的开始， 固定为低电平\n数据位： 数据帧的有效载荷， 1为高电平， 0为低电平， 低位先行\n校验位： 用于数据验证， 根据数据位计算得来\n停止位： 用于数据帧间隔， 固定为高电平\ntip 1.波特率的单位是 码元 /秒，而比特率的单位是 位 / 秒，仅在二进制解析时两者数值相等\n2.低位先行是指发送时首先发送最低位，然后是次低位，依此类推\nI2C 通信 I2C 总线（Inter IC BUS） 是由 Philips 公司开发的一种通用数据总线\n两根通信线： SCL（Serial Clock） 、 SDA（Serial Data）\n同步， 半双工\n带数据应答\n支持总线挂载多设备（一主多从、 多主多从）\n硬件电路 所有 I2C 设备的 SCL 连在一起， SDA 连在一起\n设备的 SCL 和 SDA 均要配置成开漏输出模式\nSCL 和 SDA 各添加一个上拉电阻， 阻值一般为 4.7KΩ 左右\ntip 开漏输出模式下不仅可以输出，也可以输入\nI2C 基本时序单元 起始条件： SCL 高电平期间， SDA 从高电平切换到低电平\n终止条件： SCL 高电平期间， SDA 从低电平切换到高电平\n发送一个字节： SCL 低电平期间， 主机将数据位依次放到 SDA 线上（高位先行） ， 然后释放 SCL， 从机将在 SCL 高电平期间读取数据位，所以 SCL 高电平期间 SDA 不允许有数据变化， 依次循环上述过程8次，即可发送一个字节\n接收一个字节： SCL 低电平期间， 从机将数据位依次放到 SDA 线上（高位先行） ， 然后释放 SCL， 主机将在 SCL 高电平期间读取数据位，所以 SCL 高电平期间 SDA 不允许有数据变化， 依次循环上述过程8次，即可接收一个字节（主机在接收之前， 需要释放SDA）\n发送应答： 主机在接收完一个字节之后， 在下一个时钟发送一位数据， 数据0表示应答， 数据 1 表示非应答\n接收应答： 主机在发送完一个字节之后， 在下一个时钟接收一位数据， 判断从机是否应答， 数据 0 表示应答， 数据 1 表示非应答（主机在接收之前， 需要释放 SDA）\nI2C 基本时序 I2C 通信要用上面的基本时序单元组成基本时序才可实现通信\n指定地址写 对于指定设备（Slave Address） ， 在指定地址（Reg Address） 下，写入指定数据（Data）\n当前地址读 对于指定设备（Slave Address） ， 在当前地址指针指示的地址下，读取从机数据（Data）\n指定地址读 对于指定设备（Slave Address） ， 在指定地址（Reg Address） 下，读取从机数据（Data）\nSPI通信 SPI，Serial Peripheral Interface，串行外围设备接口\n同步、串行、全双工 主从工作方式，一主一从或一主多从 四线控制 SDO，主设备数据输出，从设备数据输入（又称MOSI，master output slave input） SDI，主设备数据输入，从设备数据输出（又称MISO，master input slave output） SCLK，时钟信号，由主设备产生 CS，片选信号，从设备使能信号，由主设备控制 硬件电路图\n时序图及 SPI 模式\nCAN通信 相关内容前去 学点 | CAN通信协议 查看\n","pubDate":"2023-01-15","title":"【电赛】通信协议"},{"link":"http://gzpeng233.github.io/en/posts/science_surf_github/","plain":"开发最常见的问题就是Github连接较慢，如何才能连接Github不掉网，这里记录我使用的几种方式\n科学上网 速度最快的，首当其冲的就是科学上网，有关步骤冲浪查找\ntip 优点：范围广，可查看网站较多\n缺点：稳定性较弱，时灵时不灵\nWatt Toolkit Watt Toolkit 原名 steam++，但与 steam 毫无关联。使用 Watt Toolkit 能实现许多网站加速（不止 GitHub）\n下载地址直接在应用商店搜索即可，而且免费（doge）\n以下是开发中最常见的配置\nuu加速器 直接搜索 学术资源 即可\nwarning 据说此方法可行，但至今我未成功，网速太慢了\n总结 网速：科学上网 \u0026gt; Watt Toolkit \u0026gt; uu加速器\n稳定性：Watt Toolkit \u0026gt; 科学上网 \u0026gt; uu加速器\n","pubDate":"2023-01-13","title":"【杂货】如何科学连接GitHub"},{"link":"http://gzpeng233.github.io/en/posts/trouble_solve/","plain":"记录一些开发常见的问题\ngit相关 如果在 push 时报了以下错误，可能是上次科学上网忘记关了\n1 2 3 4 5 6 kex_exchange_identification: Connection closed by remote host Connection closed by 20.205.243.166 port 22 fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 解决方法：\nwin + R，输入 cmd，之后输入以下命令刷新 dns 缓存即可\n1 ipconfig /flushdns 其他 如果在英文输入情况下，每个字母或数字之间间距过大（就像一个字母一个空格一样），那么在中文状态下同时按 shift (primary) 和 space (primary) 即可恢复\n","pubDate":"2023-01-10","title":"【杂货】一些开发常见问题"},{"link":"http://gzpeng233.github.io/en/posts/wxminiprogram_help/","plain":"将常用的微信小程序开发过程中使用的网址放在这里，方便使用。\nvant weapp 官网 网址：Vant Weapp\ntip vant weapp 目前还在持续更新，随时来官网看看，能有不同的收获\ngit 代码管理 使用 git 管理代码要用到远程仓库目前有两个热门\n一：Gitee.com\n二：GitHub\ntip 区别是 gitee 是国内服务器，网速较快，github 是国外服务器，需要科学上网\njsDoc注释 参考网址：jsDoc注释规范\n快速掌握：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 相关介绍 * @author 该类/方法的作者 * @class 表示这是一个类 * @function/@method 表示这是一个函数/方法(这是同义词) * @private 表示该类/方法是私有的，JSDOC 不会为其生成文档 * @name 该类/方法的名字 * @description 该类/方法的描述 * @param 该类/方法的参数，可重复定义 * @return 该类/方法的返回类型 * @version 当前代码的版本 * @copyright 代码的版权信息 * @overview 对当前代码文件的描述 * @link 创建超链接，生成文档时可以为其链接到其他部分 * @example * wx.cloud.callFunction({ name: \u0026#39;getBookInfo\u0026#39;, data: { isbn: 9787201077642 } }) */ // 举例如下： /** * @author someone * @function * @name functionExample * @description 调用 functionExample 函数 * @param {object} event - 这是一个包含 string 类型的someParam 参数的对象 * @return {string} event 参数的 someParam 属性 */ functionExample(event){ return event.someParam } 微信开发文档 微信开发文档是开发中最核心的参考文档，这里 是它的网址\n下列内容大多也是基于此文档整理\n云开发 只要是设计永久性保存数据，就需要用到云开发\n云数据库 本地操作 插入数据：插入数据 | 微信开放文档 (qq.com)\n删除数据：删除数据 | 微信开放文档 (qq.com)\n更新数据：更新数据 | 微信开放文档 (qq.com)\n查询数据：查询数据 | 微信开放文档 (qq.com)\n查询、更新数组/嵌套对象：查询、更新数组/嵌套对象 | 微信开放文档 (qq.com)\n联表查询：联表查询 | 微信开放文档 (qq.com)\ntip 1.查询数据时使用 指令 能完成高端操作\n2.联表查询 是指需要用某一数据库中的数据去往另一数据库中再次查询，最终才能拿到结果。如果暴力搜索，那么将是O(m*n)的复杂度，因此微信提供了联表查询，也就是俗称的表连接\n3.若以上均无法满足要求，查找 官方API\n管理端操作 网址：数据库脚本 | 微信开放文档 (qq.com)\ntip 管理端操作是指在云开发中的云数据库中的“模板”处实现的操作\n云存储 网址：API 指引 | 微信开放文档 (qq.com)\n云函数 网址：云函数 | 微信开放文档 (qq.com)\n云开发总结 tip 全面学习云开发可以从下面两个网址来进行\n基础内容：开发指引\n全部内容（包括各种API）：开发者资源\n缓存 保存至本地缓存：wx.setStorageSync(string key, any data)\n从本地缓存移除：wx.removeStorageSync(string key)\n从本地缓存读取：wx.getStorageSync(string key)\n页面相关内容 页面 Page 相关函数 网址：Page(Object object)\n下图说明了页面 Page (primary) 实例的生命周期\n页面栈 相关内容网址：getCurrentPages()\n示例：\n1 2 3 4 5 6 7 8 9 10 // 获取当前页面栈 const pages = getCurrentPages(); // 获取上一页面对象 let prePage = pages[pages.length - 2]; // 进行具体操作等 prePage.data.content.splice(index, 1) prePage.setData({ content: prePage.data.content }) 自定义组件构建 详细介绍：自定义组件\n具体内容：Component(Object object)\n文件管理系统 在微信小程序中下载文件需要通过多个API的调用\ntip 文件系统总述：文件系统 | 微信开放文档 (qq.com)\n如何下载网络文件：微信小程序下载文件，保存文件功能总结\n从云存储下载到手机本地源代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 预览文件 downloadAllFiles() { let link = this.data.nurlList[0] //下载云存储文件为临时文件 wx.cloud.downloadFile({ fileID: link, // 文件 ID success: res =\u0026gt; { // 返回临时文件路径 console.log(res.tempFilePath) // 预览临时文件（能够下载及转发） wx.openDocument({ filePath: res.tempFilePath, showMenu: true, success: function (res) { console.log(\u0026#39;打开文档成功\u0026#39;) } }) }, fail: console.error }) } 其他 object \u0026amp; string 有时对象不能直接作为传递的参数使用，需要转为字符串，之后再转换为对象使用\n网络图片 url 编码与解码 在页面跳转时不能携带原有的网络 url，否则会使得跳转后的参数获取不完整，这时需要编码，之后再进行解码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // -------------原页面--------------- // 携带参数将对应的数组信息传递到修改信息页面 goToNewPage(e) { // 跳转前对图片中的url进行编码 image_list.forEach((i, idx) =\u0026gt; { image_list[idx] = encodeURIComponent(i) }) wx.navigateTo({ url: \u0026#39;../sellBook/sellBook?image_list=\u0026#39; + image_list, }) } // ---------------跳转后的页面--------------- // 循环解析url getUrl(url) { if (url.indexOf(\u0026#39;%\u0026#39;) \u0026lt; 0) { return url } else { const newUrl = decodeURIComponent(url) return this.getUrl(newUrl) } }, onLoad(options){ var image_list = options.image_list // 首先进行url解码 image_list.forEach((i, idx) =\u0026gt; { image_list[idx] = this.getUrl(i) }) } 零碎知识 获取窗口信息：wx.getWindowInfo()\n渐变色：linear-gradient()\n定时器：number setTimeout(function callback, number delay, any rest)\ntip 使用 wx.getWindowInfo() 获取窗口高度时使用 windowHeight 参数\n","pubDate":"2023-01-08","title":"【微信小程序】帮助文档"},{"link":"http://gzpeng233.github.io/en/posts/collection/","plain":"下面是一些杂货，可能会用得到，不定时更新\n“必” 必看网址 CS自学指南\n必备技能 Word论文排版教程\n必备工具 LaTeX——论文排版 Typora——markdown书写\nHugo——快速创建网站\nGit——分布式版本控制系统\nXmind思维导图\nSnipaste——非常好用的截图软件\n必备网站 GitHub——最大代码共享平台\n在线LaTeX公式编辑器-编辑器\n思维导图在线生成器\n阿里巴巴矢量图标库\n临时邮箱——10分钟邮箱\n地址生成器\n论文查重 微信小程序：paperyy\n推荐网课 大学物理\n数字电路\n","pubDate":"2022-12-15","title":"【杂货】一些杂货"},{"link":"http://gzpeng233.github.io/en/posts/git/","plain":"本篇基于 commit 介绍 git 相关的操作，看之前了解一下与 git 有关的基本概念\n本地 git 主要命令 创建提交记录 1 git commit 创建一个新的提交记录，位置位于当前HEAD下方\ntip 加 -m 参数可以在提交时添加提交详细信息，代码如下\n1 git commit -m \u0026#34;this is the first commit.\u0026#34; 这样在用 git log 查看时便会有具体信息，方便记忆与分辨\n创建分支 1 git branch newImage 创建一个名为newImage的分支，引用位置位于当前HEAD\n1 git checkout newImage 检出分支，使得当前HEAD移向newImage\ntip 检出分支也可使用git switch newImage，因为git checkout有了太多的功能，所以 git 新推出了这样一个命令，最终将会取代使用git checkout newImage检出分支\n1 git checkout -b newImage 创建并检出newImage分支，这个命令更简单，相当于上面两条命令的组合。当然，下面的命令也可实现此功能\n1 git switch -c newImage 合并分支——1 1 git merge bugFix 将当前分支合并至 bugFix 分支，这个命令实现的合并将会包含两个父节点。如下图\ntip 当 bugFix 分支比当前 HEAD 所处分支还要先进时，git merge bugFix 会快速移动，即当前 HEAD 所指向的分支会直接指向 bugFix\n合并分支——2 1 git rebase main 将当前分支合并至 main 分支，但是这种分支将先会复制当前分支上的提交，然后粘贴至 main 下方，最终看起来是一条线，像这样\n合并后\u0026mdash;\u0026mdash;\u0026gt;\ntip 当然，与 merge 合并类似，如果 main 分支比当前 HEAD 所处分支先进，git 也会直接快速移动\ngit 相关特性 HEAD分离 1 git checkout \u0026lt;commit_id\u0026gt; // commit_id为每次提交的提交号（就是一长串数字与英文字母组合的那个东西，像fed2da64c0efc5293610bdd892f82a58e8cbc5d8） 将会让HEAD指向\u0026lt;commit_id\u0026gt;，而不在某个分支上，像下面\n1 git checkout c2 ----输入该命令后 相对引用 1 git checkout main^ 将会指向 main 的第前一个节点，如果想指向第前n个节点，只需n个^即可\n但是，以下的命令更加方便\n1 git checkout main~5 这个命令将会指向 main 的第前5个节点\n撤销变更 1 git reset HEAD~1 将会使当前分支指向 HEAD~1 的位置，即撤销一次提交\nwarning 以上命令仅限于本地使用，若想修改后提交至远程仓库，使用以下命令\n1 git revert HEAD~1 与第一个不同的是，这个命令表面上看不仅不会撤回，还会产生一个新的提交，但是这个新的提交是 HEAD~1 的拷贝，所以最终效果是撤销而不是提交\n自由修改提交树 复制 commit 1 git cherry-pick c2 c4 将会复制 commit id 为 c2、c4 的所有更改，在当前 HEAD 提交2次，如下图\n具体修改当前分支 1 git rebase -i HEAD~4 输入这个命令后，将会产生一个 GUI，你可以任意改变距离 HEAD 最近4个提交的顺序，也可以任意删除这些提交\n你所作的所有改变，git 将会复制一遍每次 commit 的具体信息，并再次提交，类似这样\n远程 基础内容 基本概念——远程仓库 \u0026amp; 远程分支 primary 远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录\n1 git clone github.com 从技术上来讲，git clone 命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从 github.com）\n远程分支反映了远程仓库(在你上次和它通信时)的状态\n1 \u0026lt;remote name\u0026gt;/\u0026lt;branch name\u0026gt;\t// 远程分支的命名含义 基本操作——fetch Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据\n当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库，获取数据的代码如下\n1 git fetch 这个代码不会改变本地的任何分支，它的意义单纯就是将远程仓库的最新状态搬移到远程分支上来\n基本操作——pull 除了仅仅获取远程仓库的状态，我们还需要将其合并至本地分支以继续进行我们的工作，当然，这有很多方法\n1 2 3 git cherry-pick origin/main git rebase origin/main git merge origin/main 合理利用以上句子，均能实现想要的效果，但是，有些句子很常用，故而 git 将其封装起来，形成了简洁的方法\n1 git pull git pull 就是 git fetch 和 git merge 的缩写！\n基本操作——push 我们已经知道如何下载了，响应的如何上传也需要掌握\n1 git push warning 注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。\n基本操作——pull --rebase (primary) 前面讲过 git pull 相当于 git fetch 和 git merge 的缩写，而这里的 git pull \u0026ndash;rebase 相当于 git fetch 和 git rebase 的缩写\n1 git pull --rebase 远程服务器拒绝! ( Remote Rejected ) 这部分内容不过多陈述，简而言之就是一句\n把主分支还原成远程仓库的分支（为下一次 pull 奠定基础，防止冲突），然后新建分支，在新建分支上进行更改并推送，然后发起 pull request 请求\n进阶内容 远程追踪 当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 origin/main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main\norigin/main 并不一定和 main 是相关的，我们也可以强行改掉它（虽然一般没人这么做）\n有两种方法可以改掉，第一种是通过远程分支检出一个新的分支\n1 git checkout -b totallyNotMain o/main 另一种目前我不知道（ ）\npush的参数 push 时的具体参数可以让你做更多的事情，事半功倍\n1 2 git push \u0026lt;remote\u0026gt; \u0026lt;place\u0026gt; git push origin main 当然，如果来源和去路并不同名，比如你想将 feature push 到 main 分支上（真的有人这么做吗），也是可以的\n1 2 3 git push origin \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; git push origin feature:main git push origin feature~2:main fetch 的参数 git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）\n1 2 git fetch \u0026lt;remote\u0026gt; \u0026lt;place\u0026gt; git fetch \u0026lt;remote\u0026gt; \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; tip 这里 pull 的 \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; 正好和 push 的方向相反\n没有 source 的 source 在 push 与 fetch 时也可指定空的 source\npush 时：结果为删除相应的远程仓库分支\nfetch 时：创建一个新的本地分支\npull pull 没啥特殊的了，只不过相当于 fetch 后 merge 而已\n1 2 git pull \u0026lt;remote\u0026gt; \u0026lt;place\u0026gt; git pull \u0026lt;remote\u0026gt; \u0026lt;source\u0026gt;:\u0026lt;destination\u0026gt; 其他 这篇文章是在看过 Learn Git Branching 之后写的，相当于是对其中的语句做了一些简要的总结，方便我在之后需要时查阅。当然对屏幕前的你有用那更好了\n","pubDate":"2022-12-12","title":"【git】基础篇"},{"link":"http://gzpeng233.github.io/en/posts/ssh_config/","plain":"ssh, Secure Shell（安全外壳协议），利用ssh访问仓库可避免输入用户名与密码，节省开发时间\n一、所需环境 安装 Git 本地安装 Git，未安装用户可以点击 Git官网 进行下载\n注册账号 注册需要配置 ssh 平台的账号（Github，Gitee，Gitlab，Coding）\n二、具体步骤 检查系统是否存在 .ssh 文件夹 windows系统下一般是在 C:\\Users\\Administrator 目录下，如果没有手动新建 .ssh 文件夹\n生成 ssh key 创建 .ssh 目录 进入 .ssh 目录下，单机鼠标右键，选择 Git Bash here，打开 git bash\n选择需求，继续进行设置\n::: tabs\n@tab 单一平台\n生成 ssh key 输入以下命令生成 ssh\n1 ssh-keygen -t rsa -C \u0026#34;xxx@xxx.com\u0026#34; 引号中的内容是你在 github 上注册所使用的邮箱，点击确定。(以 GitHub 为例)\n继续回车确定，会提示你设置密码和再次输入密码。为了简化操作，这里不建议设置密码，直接回车确定。\n再次回车确定，看到如下样式，就说明 ssh 生成成功了，在 .ssh 文件夹会下看到 id_rsa 文件和 id_rsa.pub 文件。\n设置远程仓库 将生成的 key 添加到 github（或 gitee 等）账户中去 打开生成的 id_rsa.pub 文件，全选并复制内容 登录 github，点击 右上角头像 \u0026ndash;\u0026gt; Setttings \u0026ndash;\u0026gt; SSH and GPG keys \u0026ndash;\u0026gt; New SSH keys Titile 随意起名，Key 中粘贴上刚刚拷贝的公钥 点击 Add SSH key，输入密码即可 测试 可输入以下代码进行测试\n1 ssh -T git@github.com 出现以下提示即连接成功\n1 Hi, xxxx ! You have successfully authenticated, but GitHub does not provide shell access. tip but GitHub does not provide shell access 这句话其实一直存在，它只是想告诉你，github 不允许 shell 交互。仅此而已。\n@tab 多平台\n生成 ssh key 输入以下命令生成 ssh\n1 ssh-keygen -t rsa -C \u0026#34;xxx@xxx.com\u0026#34; 引号中的内容是你在 github 上注册所使用的邮箱，点击确定。(以 GitHub 为例)\n这里需要注意，该命令会默认生成为 id_rsa 的公钥和 id_rsa.pub 的私钥文件。为了防止后续生成别的 ssh 被覆盖，这里推荐手动修改文件名。例如，这里修改为 id_rsa_github\n继续回车确定，会提示你设置密码和再次输入密码。为了简化操作，这里不建议设置密码，直接回车确定。\n再次回车确定，看到如下样式，就说明 ssh 生成成功了，在 .ssh 文件夹会下看到 id_rsa_github 文件和 id_rsa_github.pub 文件。\n设置远程仓库 将生成的 key 添加到 github（或 gitee 等）账户中去 打开生成的 id_rsa_github.pub 文件，全选并复制内容 登录 github，点击 右上角头像 \u0026ndash;\u0026gt; Setttings \u0026ndash;\u0026gt; SSH and GPG keys \u0026ndash;\u0026gt; New SSH keys Titile 随意起名，Key 中粘贴上刚刚拷贝的公钥 点击 Add SSH key，输入密码即可 切换账号继续生成 ssh 完成以上步骤就生成配置好了 github 的 ssh key，可以使用 ssh 方式克隆或者推送代码到 github 远程仓库。gitee 或 gitlab 或 coding 的生成方法也是如此，重复以上步骤即可。\ntip 重复执行第二步时绑定邮箱时建议使用不同邮箱，方便区分。（不使用也可）\n重复执行第三步时需要修改生成的文件名，防止覆盖。可以使用平台名作为后缀，如（id_rsa_github / id_rsa_gitee）\n重复以上步骤后，在文件目录下会看到生成了多个 ssh key ，分别对应不同的代码托管平台。如图：\n配置 config 文件 在 .ssh 文件夹中手动创建 config 文件或者输入命令 touch config (primary) 生成，并按下面的模板填写，该文件用于配置私钥对应的服务器。\n1 2 3 4 5 6 7 8 9 10 11 # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa # gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa tip 配置说明：\nHost：自定义别名，会影响 git 相关命令\nHostName：真实的服务器地址（域名）\nUser：之前配置的用户名可以省略（xxx@xxx.com）\nPreferredAuthentications：权限认证（publickey,password publickey,keyboard-interactive）一般直接设为 publickey\nIdentityFile：rsa 文件地址\n测试 可输入以下代码进行测试\n1 ssh -T git@github.com 出现以下提示即连接成功\n1 Hi, xxxx ! You have successfully authenticated, but GitHub does not provide shell access. tip but GitHub does not provide shell access 这句话其实一直存在，它只是想告诉你，github 不允许 shell 交互。仅此而已。\n:::\n","pubDate":"2022-12-09","title":"【git】ssh配置"},{"link":"http://gzpeng233.github.io/en/posts/matlab/","plain":"本篇文章介绍下matlab的相关绘图知识。\n绘图 绘制二维连续函数——plot (primary) plot是最基本的平面图形绘制函数,plot的命令格式有以下几种\nplot(y) (primary)\n当 y 为向量时，以 y 的序号作为横轴按向量 y 的值绘制曲线 当 y 为实矩阵时，按列绘制曲线,绘制的曲线总数即为矩阵的列数 当 y 为复数矩阵时,按列分别以元素的实部为横轴,部为纵轴坐标绘制多条曲线相当于 plot(real(y),imag(y)) (primary) plot(x,y) (primary)\nx，y 均为向量时,以 x 向量作为 X 轴(横坐标),向量作为 Y 轴(纵坐标),且按照向量 x，y 中元素的排列顺序有序绘制曲线，但 x 与 y 必须拥有相同的长度 当 x 是向量，y 是矩阵时，以 x 作为 X 轴绘制多根不同色彩的曲线，曲线总数等于 y 的另一维数 当 x 是矩阵，y 是向量时,与上一情况相似，以 y 为 Y 轴绘制多条不同色彩的曲线 当 X 和 y 为同维矩阵时，以 x 与 y 对应的列元素为横坐标绘制多条曲线，总数等于矩阵的列数 plot(x,y,s) (primary)\ns 是字符串型变量,用来指定线型色彩数据点型等,当其缺省时，MATLAB 按默认设置处理，s 参数的取值见下表 plot(x1,y1,s1,x2,y2,s3,x3,y3,s3,……) (primary)\n在一张图中多次使用 plot(x,y,s) 指令。只是同时在图形窗口中绘制多条曲线，这些曲线之间没有约束。其中 x、y 为向量或矩阵，s 为字符串型变量。 warning plot 返回各线对象的句柄列向量,每一条线对应一个句柄\n绘制二维离散序列——stem (primary) 用stem绘制离散序列，其格式有一下几种：\nstem(y) (primary) 以 x =1,2,3,…… (缺省)为各点数据的 X 坐标,以 y 向量的各个对应元素为 Y 坐标,在( X,Y )坐标面画一个空心小圆圈,并连接一条线段到 X 轴 stem(x,y,'filled') (primary) 以 x 向量的各个元素为 X 坐标,以 y 向量的各个对应元素为 Y 坐标,在 (X,Y) 坐标面画一个实心小圆圈,并连接一条线段到 X 轴 其他二维图形 其他常见的绘图函数如下所示\n图形控制 坐标控制 见下表\n图形注释 见下表\n","pubDate":"2022-12-07","title":"【matlab】绘图篇"},{"link":"http://gzpeng233.github.io/en/posts/git_ex/","plain":"为常用的代码设置别名，可以极大的提高敲代码的速度。\n设置别名 简单设置 git config --global alias.xx xxxx (primary)则可用xx (primary)代表xxxx (primary)，例如：\n1 2 3 4 git config --global alias.co checkout # 别名 git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch 设置之后：\n1 2 3 4 git co git ci git st git br 上式则可代表\n1 2 3 4 git checkout git commit git status git branch 组合设置 甚至可以进行一些组合的别名设置，例如：\n1 2 git config --global alias.psm \u0026#39;push origin master\u0026#39; git config --global alias.plm \u0026#39;pull origin master\u0026#39; 查看别名 以下代码可以查看本机的Git (primary)配置\n1 git config -l 删除别名 当想删除已设置别名时可以这样做：\n1 git config --global --unset alias.xx 则可删除别名xx (primary)\n删除所有别名 当想删除所有别名时，可以这样做：\n1 git config --global --remove-section alias 额外知识 这样设置git log (primary)可以更清晰的查看日志\n1 git config --global alias.lg \u0026#34;log --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit --date=relative\u0026#34; tip 参数--global代表全局配置，即整个计算机上的配置；若只是当前仓库的设置，去掉此参数即可\n","pubDate":"2022-11-25","title":"【git】进阶篇"},{"link":"http://gzpeng233.github.io/en/posts/wxminiprogram_npm_i/","plain":"前言 小程序对 npm 的支持与限制 目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用 npm 包有如下3个限制:\n不支持依赖于 Node.js 内置库的包\n不支持依赖于浏览器内置对象的包\n不支持依赖于 C++ 插件的包\n总结:虽然 npm 上的包有千千万，但是能供小程序使用的包却为数不多\n什么是 Vant Weapp Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议，对商业使用比较友好。\n官方文档地址：介绍 - Vant Weapp (youzan.github.io)\n安装 Vant 组件库 在小程序项目中，安装 Vant 组件库主要分为如下几步\n安装 vant 在 miniprogram 文件夹处右击，选择内建终端，使用以下代码进行安装 vant\n1 npm i @vant/weapp@1.3.3 -S --production // 其中1.3.3为版本号 修改 app.json 去除 app.json 中的 \u0026quot;style\u0026quot;: \u0026quot;v2\u0026quot;\n修改 project.config.json 修改 project.config.json 为以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { ... \u0026#34;setting\u0026#34;: { ... \u0026#34;packNpmManually\u0026#34;: true, \u0026#34;packNpmRelationList\u0026#34;: [ { \u0026#34;packageJsonPath\u0026#34;: \u0026#34;./package.json\u0026#34;, \u0026#34;miniprogramNpmDistDir\u0026#34;: \u0026#34;./\u0026#34; } ] } } 构建 npm 包 点击工具 -\u0026gt; 构建 npm，并勾选 使用 npm 模块 选项，构建完成后，即可引入组件。\ntip 如果是新版微信开发者工具，则不需要勾选使用 npm 模块，因为其默认使用\n","pubDate":"2022-11-22","title":"【微信小程序】vant-weapp使用"}];
    var search_theEnd = "The End";
    var search_nothing = "Nothing was found";
    var search_found = "Found";
    var search_result = "result";
    var search_results = "results";
</script>





    </body>
</html>

